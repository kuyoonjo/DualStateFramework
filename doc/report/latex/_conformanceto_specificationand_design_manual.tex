Fortunately, the submitted product matches all functionalities that my specification and design documents mentioned. \hypertarget{_conformanceto_specificationand_design_manual_SetupDevelopmentEnvironment}{}\section{Setup Development Environment}\label{_conformanceto_specificationand_design_manual_SetupDevelopmentEnvironment}
The operating system of my laptop is Mac O\+S X Yosemite \cite{osxyosemite}. I have installed V\+Mware Fusion \cite{vmwarefusion} and have created two virtual machine for other operating systems(Microsoft Windows 7 \cite{microsoftwindows7} and Ubuntu 14.\+04 L\+T\+S \cite{ubuntu14_04LTS}). The development will be mainly taken place under Mac, and tested in all these three operating systems. \hypertarget{_conformanceto_specificationand_design_manual_SetupDevelopmentEnvironmentCppCompilerandIDE}{}\subsection{C++ Compiler and I\+D\+E}\label{_conformanceto_specificationand_design_manual_SetupDevelopmentEnvironmentCppCompilerandIDE}
\begin{DoxyParagraph}{Mac O\+S X}
To setup Xcode \cite{xcode} and default C++ compiler L\+L\+V\+M \cite{llvm} in Mac O\+S X is very easy.
\begin{DoxyItemize}
\item Open App Store → search \char`\"{}\+Xcode\char`\"{} → click \char`\"{}get\char`\"{} button
\end{DoxyItemize}
\end{DoxyParagraph}
After the installation, the I\+D\+E Xcode and the compiler L\+L\+V\+M is installed. To see the information about clang by command \char`\"{}clang -\/-\/version\char`\"{}. 
\begin{DoxyCode}
MacBook-Pro:~ yuchen$ clang --version
Apple LLVM version 6.1.0 (clang-602.0.49) (based on LLVM 3.6.0svn)
Target: x86\_64-apple-darwin14.3.0
\end{DoxyCode}
 \begin{DoxyParagraph}{Microsoft Windows}
Download Visual Studio Community \cite{visualstudiocommunity} from \href{https://www.visualstudio.com}{\tt https\+://www.\+visualstudio.\+com} and install it. Visual Studio has its own embedded C++ compiler. 
\end{DoxyParagraph}
\begin{DoxyParagraph}{Ubuntu}
Open a terminal and type following command to install the G\+N\+U Compiler Collection(\+G\+C\+C) \cite{gcc} 
\begin{DoxyCode}
sudo apt-\textcolor{keyword}{get} install build-essential
\end{DoxyCode}
 Type \char`\"{}gcc -\/v\char`\"{} to print the descriptions. 
\begin{DoxyCode}
yu@ubuntu:~$ gcc -v
Using built-in specs.
COLLECT\_GCC=gcc
COLLECT\_LTO\_WRAPPER=/usr/lib/gcc/x86\_64-linux-gnu/4.8/lto-wrapper
Target: x86\_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion=\textcolor{stringliteral}{'Ubuntu 4.8.2-19ubuntu1'} --with-bugurl=file:
Thread model: posix
gcc version 4.8.2 (Ubuntu 4.8.2-19ubuntu1) 
\end{DoxyCode}

\end{DoxyParagraph}
\hypertarget{_conformanceto_specificationand_design_manual_SetupDevelopmentEnvironmentThirdpartylibraries}{}\subsection{Third party libraries}\label{_conformanceto_specificationand_design_manual_SetupDevelopmentEnvironmentThirdpartylibraries}
\begin{DoxyParagraph}{Intel Threading Building Blocks}
Intel T\+B\+B \cite{inteltbb} is a C++ library for parallel computing. Use Homebrew \cite{homebrew} to Install the library for Mac O\+S X\+: 
\begin{DoxyCode}
$ brew install libtbb
\end{DoxyCode}
 For Ubuntu use following command 
\begin{DoxyCode}
$ sudo apt-\textcolor{keyword}{get} install libtbb2
\end{DoxyCode}
 For Window need go to its download page \href{https://www.threadingbuildingblocks.org/download}{\tt https\+://www.\+threadingbuildingblocks.\+org/download}. Download the Windows version binaries package and unzip it.
\begin{DoxyItemize}
\item First, create a a new folder. The full path of it is \char`\"{}\+C\+:\textbackslash{}\+Program Files\textbackslash{}tbb\char`\"{}. Inside the folder create three folders \char`\"{}include\char`\"{}, \char`\"{}lib\char`\"{}, and \char`\"{}bin\char`\"{}.
\item Secondly, go to the unzipped folder. Copy everything inside the \char`\"{}include\char`\"{} to the \char`\"{}include\char`\"{} has just been created.
\item Inside the \char`\"{}lib\char`\"{}, there are two folders \char`\"{}ia32\char`\"{} and \char`\"{}intel64\char`\"{} that means the architecture of operating system. My Window 7 is 32 bits, so I chose the \char`\"{}ia32\char`\"{}. Again, inside \char`\"{}ia32\char`\"{}, there are many folders those are the versions of Visual Studio. The version of Visual Studio that I installed is 2013. The core of Visual Studio 2013 is vs2012, so copy all files inside \char`\"{}vc12\char`\"{} to the folder \char`\"{}lib\char`\"{} which has just been created.
\item Inside the \char`\"{}bin\char`\"{}, do the same thing as \char`\"{}lib\char`\"{} did.
\item Create a environment variable \char`\"{}tbb\char`\"{} refers to the directory \char`\"{}\+C\+:\textbackslash{}\+Program Files\textbackslash{}tbb\char`\"{}.
\end{DoxyItemize}
\end{DoxyParagraph}
\begin{DoxyParagraph}{S\+F\+M\+L}
Simple and Fast Multimedia Library(S\+F\+M\+L \cite{sfml}) is a graphics library. For Mac, just go to the download page \href{http://www.sfml-dev.org/download/sfml/2.1/}{\tt http\+://www.\+sfml-\/dev.\+org/download/sfml/2.\+1/} to get the installer and run it. For Ubuntu, just need one line command\+: 
\begin{DoxyCode}
sudo apt-\textcolor{keyword}{get} install libsfml-dev
\end{DoxyCode}
 However, there is a problem for Windows. When I went to its download page, I could not find the version for Visual Studio 2013. The solution is to compile the source code which can be cloned from \href{https://github.com/LaurentGomila/SFML.git}{\tt https\+://github.\+com/\+Laurent\+Gomila/\+S\+F\+M\+L.\+git}.
\end{DoxyParagraph}
\hypertarget{_conformanceto_specificationand_design_manual_SetupDevelopmentEnvironmentOtherTools}{}\subsection{Other Tools}\label{_conformanceto_specificationand_design_manual_SetupDevelopmentEnvironmentOtherTools}

\begin{DoxyItemize}
\item Source\+Tree \cite{sourcetree}, a G\+U\+I git front-\/end, which is available in both Mac and Windows.
\item cmake-\/gui \cite{cmakegui}, the official G\+U\+I front-\/end for C\+Make, available in Mac, Windows, and Linux.
\end{DoxyItemize}\hypertarget{_conformanceto_specificationand_design_manual_StartDevelopment}{}\section{Start Development}\label{_conformanceto_specificationand_design_manual_StartDevelopment}
\hypertarget{_conformanceto_specificationand_design_manual_StartDevelopmentSourceControl}{}\subsection{Source Control}\label{_conformanceto_specificationand_design_manual_StartDevelopmentSourceControl}
I used git for source control. The repository is available at \href{https://github.com/kuyoonjo/DualStateFramework.git}{\tt https\+://github.\+com/kuyoonjo/\+Dual\+State\+Framework.\+git}. \hypertarget{_conformanceto_specificationand_design_manual_StartDevelopmentCodeConfigurations}{}\subsection{Code Configurations}\label{_conformanceto_specificationand_design_manual_StartDevelopmentCodeConfigurations}
The project is designed for Mac O\+S X, Microsoft Window, and other Unix-\/like operating systems. Therefore, the code should be portable in all of them. Write different copy for different operating system is not a good idea. The best solution is prepare some configuration file, then different operating system will generate different copies. \begin{DoxyParagraph}{Config.h}

\begin{DoxyCode}
\textcolor{preprocessor}{#ifndef dsf\_Config\_h}
\textcolor{preprocessor}{#define dsf\_Config\_h}

\textcolor{preprocessor}{#if defined(\_WIN32)}

\textcolor{comment}{// Windows compilers need specific (and different) keywords for export and import}
\textcolor{preprocessor}{#define DSF\_API\_EXPORT \_\_declspec(dllexport)}
\textcolor{preprocessor}{#define DSF\_API\_IMPORT \_\_declspec(dllimport)}

\textcolor{comment}{// For Visual C++ compilers, we also need to turn off this annoying C4251 warning}
\textcolor{preprocessor}{#ifdef \_MSC\_VER}

\textcolor{preprocessor}{#pragma warning(disable : 4251)}

\textcolor{preprocessor}{#endif}

\textcolor{preprocessor}{#else // Linux, FreeBSD, Mac OS X}

\textcolor{preprocessor}{#if \_\_GNUC\_\_ >= 4}

\textcolor{comment}{// GCC 4 has special keywords for showing/hidding symbols,}
\textcolor{comment}{// the same keyword is used for both importing and exporting}
\textcolor{preprocessor}{#define DSF\_API\_EXPORT \_\_attribute\_\_ ((\_\_visibility\_\_ ("default")))}
\textcolor{preprocessor}{#define DSF\_API\_IMPORT \_\_attribute\_\_ ((\_\_visibility\_\_ ("default")))}

\textcolor{preprocessor}{#else}

\textcolor{comment}{// GCC < 4 has no mechanism to explicitely hide symbols, everything's exported}
\textcolor{preprocessor}{#define DSF\_API\_EXPORT}
\textcolor{preprocessor}{#define DSF\_API\_IMPORT}

\textcolor{preprocessor}{#endif}

\textcolor{preprocessor}{#endif}


\textcolor{preprocessor}{#endif}
\end{DoxyCode}
 
\end{DoxyParagraph}
\begin{DoxyParagraph}{Export.h}

\begin{DoxyCode}
\textcolor{preprocessor}{#ifndef dsf\_Export\_h}
\textcolor{preprocessor}{#define dsf\_Export\_h}

\textcolor{comment}{// Headers}
\textcolor{comment}{}\textcolor{preprocessor}{#include "Config.h"}


\textcolor{comment}{// Define portable import / export macros}
\textcolor{comment}{}\textcolor{preprocessor}{#if defined(dsf\_EXPORTS)}

\textcolor{preprocessor}{#define DSF\_API DSF\_API\_EXPORT}

\textcolor{preprocessor}{#else}

\textcolor{preprocessor}{#define DSF\_API DSF\_API\_IMPORT}

\textcolor{preprocessor}{#endif}

\textcolor{preprocessor}{#endif}
\end{DoxyCode}

\end{DoxyParagraph}
\hypertarget{_conformanceto_specificationand_design_manual_StartDevelopmentBuildProcessManagement}{}\subsection{Build Process Management}\label{_conformanceto_specificationand_design_manual_StartDevelopmentBuildProcessManagement}
Different I\+D\+Es use different build process managements.
\begin{DoxyItemize}
\item A bundle with extension name \char`\"{}xcodeproj\char`\"{} is an Xcode project.
\item A file with extension name \char`\"{}sln\char`\"{} is a Visual Studio Solution.
\item G\+C\+C uses Makefile.
\item Many others.
\end{DoxyItemize}

C\+Make can generate different build process systems for those. What I need is a little bit configurations for different I\+D\+Es. 
\begin{DoxyCode}
\textcolor{keywordflow}{if} (MSVC)
\textcolor{preprocessor}{    # Windows VC}
\textcolor{preprocessor}{    # Activate C++ exception handling}
    \textcolor{keywordflow}{if} (NOT CMAKE\_CXX\_FLAGS MATCHES \textcolor{stringliteral}{"/EHsc"})
    set(CMAKE\_CXX\_FLAGS \textcolor{stringliteral}{"$\{CMAKE\_CXX\_FLAGS\} /EHsc"})
    endif ()

    \textcolor{preprocessor}{# Set Warning level always to 4}
    \textcolor{keywordflow}{if} (CMAKE\_CXX\_FLAGS MATCHES \textcolor{stringliteral}{"/W[0-4]"})
        string(REGEX REPLACE \textcolor{stringliteral}{"/W[0-4]"} \textcolor{stringliteral}{"/W4"} CMAKE\_CXX\_FLAGS \textcolor{stringliteral}{"$\{CMAKE\_CXX\_FLAGS\}"})
    \textcolor{keywordflow}{else} ()
        set(CMAKE\_CXX\_FLAGS \textcolor{stringliteral}{"$\{CMAKE\_CXX\_FLAGS\} /W4"})
    endif () 
elseif(APPLE)
    \textcolor{preprocessor}{# Mac OS X Xcode}
    set(CMAKE\_MACOSX\_RPATH 1)
    ADD\_DEFINITIONS(-std=c++11)
else()
    \textcolor{preprocessor}{# Unix}
    ADD\_DEFINITIONS(-std=c++11)
endif()
\end{DoxyCode}
\hypertarget{_conformanceto_specificationand_design_manual_Implementation}{}\section{Implementation}\label{_conformanceto_specificationand_design_manual_Implementation}
\hypertarget{_conformanceto_specificationand_design_manual_ImplementationDualState}{}\subsection{Dual State}\label{_conformanceto_specificationand_design_manual_ImplementationDualState}
The idea to make an object two states is to create an abstract class named \char`\"{}\+Synchronisable\char`\"{} that any other class inherits it will have two copies. The class is designed as this\+: 
\begin{DoxyCode}
\textcolor{keyword}{template}<\textcolor{keyword}{class} T> \textcolor{keyword}{class }Synchronisable
\{
\textcolor{keyword}{protected}:
    T* next; \textcolor{comment}{//A copy of current object.}
\textcolor{keyword}{public}:
    \textcolor{keyword}{virtual} ~Synchronisable() \{
        \textcolor{keyword}{delete} this->next;
    \}
    \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} synchronise() = 0; \textcolor{comment}{//Signs current value to next value.}
\};
\end{DoxyCode}
 Any class implements the abstract class will automatically generate a copy \char`\"{}next\char`\"{} when an object is created. What we need to do is just override the method \char`\"{}synchronise\char`\"{}. For example\+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <dsf/Synchronisable.h>}

\textcolor{keyword}{class }Int
\{
\textcolor{keyword}{private}:
    \textcolor{keywordtype}{int} value;
\textcolor{keyword}{public}:
    \textcolor{keywordtype}{void} setValue(\textcolor{keywordtype}{int} value)
    \{
        this->value = value;
    \}
    \textcolor{keywordtype}{int} getValue()\textcolor{keyword}{ const}
\textcolor{keyword}{    }\{
        \textcolor{keywordflow}{return} this->value;
    \}
\};

\textcolor{keyword}{class }SynchronizedInt : \textcolor{keyword}{public} dsf::Synchronisable<Int>, \textcolor{keyword}{public} Int
\{
\textcolor{keyword}{public}:
    \textcolor{keywordtype}{void} synchronise()\textcolor{keyword}{ override}
\textcolor{keyword}{    }\{
        this->setValue(next->getValue());
    \}
\};
\end{DoxyCode}
\hypertarget{_conformanceto_specificationand_design_manual_Implementationrnd}{}\subsection{Read operation and Write operation}\label{_conformanceto_specificationand_design_manual_Implementationrnd}
Now, we need to make the current value for all read operations, and the next value for all write operations. To implement this, we just need to override the method \char`\"{}set\+Value\char`\"{}. 
\begin{DoxyCode}
\textcolor{keywordtype}{void} setValue(\textcolor{keywordtype}{int} value)
\{
    next->setValue(value);
\}
\end{DoxyCode}
 Every time we call the method \char`\"{}set\+Value\char`\"{} will effect the next, but not the current. The example code will now like this\+: 
\begin{DoxyCodeInclude}
\textcolor{preprocessor}{#include <dsf/Synchronisable.h>}

\textcolor{keyword}{class }Int
\{
\textcolor{keyword}{private}:
    \textcolor{keywordtype}{int} value;
\textcolor{keyword}{public}:
    \textcolor{keywordtype}{void} setValue(\textcolor{keywordtype}{int} value)
    \{
        this->value = value;
    \}
    \textcolor{keywordtype}{int} getValue()\textcolor{keyword}{ const}
\textcolor{keyword}{    }\{
        \textcolor{keywordflow}{return} this->value;
    \}
\};

\textcolor{keyword}{class }SynchronizedInt : \textcolor{keyword}{public} dsf::Synchronisable<Int>, \textcolor{keyword}{public} Int
\{
\textcolor{keyword}{public}:
    \textcolor{keywordtype}{void} synchronise()\textcolor{keyword}{ override}
\textcolor{keyword}{    }\{
        this->setValue(next->getValue());
    \}
    \textcolor{keywordtype}{void} setValue(\textcolor{keywordtype}{int} value)
    \{
        next->setValue(value);
    \}
\};
\end{DoxyCodeInclude}
\hypertarget{_conformanceto_specificationand_design_manual_ImplementationBenchmarkProgram}{}\subsection{Benchmark Program}\label{_conformanceto_specificationand_design_manual_ImplementationBenchmarkProgram}
For benchmarks, I used S\+F\+M\+L to create graphics. Frames per Second is the measurement for the benchmark program. Three methods of different algorithms are used\+:
\begin{DoxyItemize}
\item Random
\item Elastic collision
\item Flocking boids
\end{DoxyItemize}

Because of S\+F\+M\+L using opengl, and opengl not supporting multiple-\/thread rendering, the step of draw elements should be in serial programming phase. A class was designed for S\+F\+M\+L\+: 
\begin{DoxyCodeInclude}
\textcolor{comment}{//}
\textcolor{comment}{//  DSFSFML.h}
\textcolor{comment}{//  profiler}
\textcolor{comment}{//}
\textcolor{comment}{//  Created by Yu Chen on 2/16/15.}
\textcolor{comment}{//}
\textcolor{comment}{//}

\textcolor{preprocessor}{#ifndef profiler\_DSFSFML\_h}
\textcolor{preprocessor}{#define profiler\_DSFSFML\_h}

\textcolor{preprocessor}{#include <SFML/Graphics.hpp>}
\textcolor{preprocessor}{#include <vector>}

\textcolor{keyword}{namespace }dsf
\{
    \textcolor{keyword}{namespace }sfml
    \{
        \textcolor{keyword}{class }RenderWindow
        \{
        \textcolor{keyword}{public}:
            \textcolor{keyword}{explicit} RenderWindow();
            \textcolor{keyword}{virtual} ~RenderWindow();
            sf::RenderWindow* window;
            std::vector<sf::Drawable*>* drawables;
        \textcolor{keyword}{protected}:
            \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} draw() = 0;
        \};
    \}
\}
\textcolor{preprocessor}{#endif}
\end{DoxyCodeInclude}
 In parallel programming phase, all elements need to be drawn will be pushed in to the list drawables. In serial phase, all elements in the list will be drawn out. 