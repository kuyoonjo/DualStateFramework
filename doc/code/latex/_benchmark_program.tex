\hypertarget{_benchmark_program_BenchmarkProgramCMakeLists}{}\section{C\+Make\+Lists}\label{_benchmark_program_BenchmarkProgramCMakeLists}
\hypertarget{_benchmark_program_BenchmarkProgramCMakeListsMain}{}\subsection{C\+Make\+Lists.\+txt}\label{_benchmark_program_BenchmarkProgramCMakeListsMain}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/\+C\+Make\+Lists.txt} 
\begin{DoxyCodeInclude}
1 cmake\_minimum\_required(VERSION 2.8)
2 
3 \textcolor{preprocessor}{# project name}
4 project(profiler)
5 
6 \textcolor{preprocessor}{# setup version numbers}
7 set(VERSION\_MAJOR 1)
8 set(VERSION\_MINOR 0)
9 set(VERSION\_PATCH 0)
10 
11 
12 \textcolor{preprocessor}{# disable the rpath stuff}
13 set(CMAKE\_SKIP\_BUILD\_RPATH FALSE)
14 
15 
16 \textcolor{preprocessor}{# detect the architecture (note: this test won't work for cross-compilation)  }
17 include(CheckTypeSize)
18 check\_type\_size(\textcolor{keywordtype}{void}* SIZEOF\_VOID\_PTR)
19 if("$\{SIZEOF\_VOID\_PTR\}\textcolor{stringliteral}{" STREQUAL "}4\textcolor{stringliteral}{")}
20 \textcolor{stringliteral}{    set(ARCH x86)}
21 \textcolor{stringliteral}{elseif("}$\{SIZEOF\_VOID\_PTR\}\textcolor{stringliteral}{" STREQUAL "}8\textcolor{stringliteral}{")}
22 \textcolor{stringliteral}{    set(ARCH x64)}
23 \textcolor{stringliteral}{else()}
24 \textcolor{stringliteral}{    message(FATAL\_ERROR "}Unsupported architecture\textcolor{stringliteral}{")}
25 \textcolor{stringliteral}{    return()}
26 \textcolor{stringliteral}{endif()}
27 \textcolor{stringliteral}{}
28 \textcolor{stringliteral}{# links}
29 \textcolor{stringliteral}{set(SFML\_LIBS sfml-audio sfml-graphics sfml-network sfml-system sfml-window)}
30 \textcolor{stringliteral}{set(DSF\_LIBS tbb yctools dsf)}
31 \textcolor{stringliteral}{set(LIBS $\{SFML\_LIBS\} $\{DSF\_LIBS\})}
32 \textcolor{stringliteral}{}
33 \textcolor{stringliteral}{# headers}
34 \textcolor{stringliteral}{include\_directories($\{CMAKE\_CURRENT\_SOURCE\_DIR\}/extlibs/headers)}
35 \textcolor{stringliteral}{set(INCROOT $\{CMAKE\_CURRENT\_SOURCE\_DIR\}/include)}
36 \textcolor{stringliteral}{set(INC}
37 \textcolor{stringliteral}{    $\{INCROOT\}/BouncingCircleManager.h  }
38 \textcolor{stringliteral}{    $\{INCROOT\}/MyDSF.h          }
39 \textcolor{stringliteral}{    $\{INCROOT\}/SyncFlockingBoid.h}
40 \textcolor{stringliteral}{    $\{INCROOT\}/DSFSFML.h        }
41 \textcolor{stringliteral}{    $\{INCROOT\}/RandomCircleManager.h    }
42 \textcolor{stringliteral}{    $\{INCROOT\}/SyncVector3D.h}
43 \textcolor{stringliteral}{    $\{INCROOT\}/ResourcePath.hpp }
44 \textcolor{stringliteral}{    $\{INCROOT\}/Vector3D.h}
45 \textcolor{stringliteral}{    $\{INCROOT\}/FPS.h            }
46 \textcolor{stringliteral}{    $\{INCROOT\}/SyncBouncingCircle.h}
47 \textcolor{stringliteral}{    $\{INCROOT\}/FlockingBoidManager.h    }
48 \textcolor{stringliteral}{    $\{INCROOT\}/SyncCircle.h}
49 \textcolor{stringliteral}{)}
50 \textcolor{stringliteral}{}
51 \textcolor{stringliteral}{# source}
52 \textcolor{stringliteral}{set(SRCROOT $\{CMAKE\_CURRENT\_SOURCE\_DIR\}/src)}
53 \textcolor{stringliteral}{set(SRC}
54 \textcolor{stringliteral}{    $\{SRCROOT\}/BouncingCircleManager.cpp}
55 \textcolor{stringliteral}{    $\{SRCROOT\}/DSFSFML.cpp          }
56 \textcolor{stringliteral}{    $\{SRCROOT\}/SyncBouncingCircle.cpp       }
57 \textcolor{stringliteral}{    $\{SRCROOT\}/SyncCircle.cpp}
58 \textcolor{stringliteral}{    $\{SRCROOT\}/FPS.cpp              }
59 \textcolor{stringliteral}{    $\{SRCROOT\}/SyncFlockingBoid.cpp}
60 \textcolor{stringliteral}{    $\{SRCROOT\}/FlockingBoidManager.cpp      }
61 \textcolor{stringliteral}{    $\{SRCROOT\}/SyncVector3D.cpp}
62 \textcolor{stringliteral}{    $\{SRCROOT\}/MyDSF.cpp            }
63 \textcolor{stringliteral}{    $\{SRCROOT\}/Vector3D.cpp}
64 \textcolor{stringliteral}{    $\{SRCROOT\}/RandomCircleManager.cpp      }
65 \textcolor{stringliteral}{    $\{SRCROOT\}/main.cpp}
66 \textcolor{stringliteral}{)}
67 \textcolor{stringliteral}{}
68 \textcolor{stringliteral}{# resources}
69 \textcolor{stringliteral}{set(RESRCROOT $\{PROJECT\_SOURCE\_DIR\}/resource)}
70 \textcolor{stringliteral}{}
71 \textcolor{stringliteral}{# os configurations}
72 \textcolor{stringliteral}{if (MSVC)}
73 \textcolor{stringliteral}{    # Windows VC}
74 \textcolor{stringliteral}{    # Activate C++ exception handling}
75 \textcolor{stringliteral}{    if (NOT CMAKE\_CXX\_FLAGS MATCHES "}/EHsc\textcolor{stringliteral}{")}
76 \textcolor{stringliteral}{    set(CMAKE\_CXX\_FLAGS "}$\{CMAKE\_CXX\_FLAGS\} /EHsc\textcolor{stringliteral}{")}
77 \textcolor{stringliteral}{    endif ()}
78 \textcolor{stringliteral}{}
79 \textcolor{stringliteral}{    # Set Warning level always to 4}
80 \textcolor{stringliteral}{    if (CMAKE\_CXX\_FLAGS MATCHES "}/W[0-4]\textcolor{stringliteral}{")}
81 \textcolor{stringliteral}{        string(REGEX REPLACE "}/W[0-4]\textcolor{stringliteral}{" "}/W4\textcolor{stringliteral}{" CMAKE\_CXX\_FLAGS "}$\{CMAKE\_CXX\_FLAGS\}\textcolor{stringliteral}{")}
82 \textcolor{stringliteral}{    else ()}
83 \textcolor{stringliteral}{        set(CMAKE\_CXX\_FLAGS "}$\{CMAKE\_CXX\_FLAGS\} /W4\textcolor{stringliteral}{")}
84 \textcolor{stringliteral}{    endif () }
85 \textcolor{stringliteral}{}
86 \textcolor{stringliteral}{    # Add Math definitions}
87 \textcolor{stringliteral}{    add\_definitions(-D\_USE\_MATH\_DEFINES)}
88 \textcolor{stringliteral}{}
89 \textcolor{stringliteral}{    # Add Source}
90 \textcolor{stringliteral}{    set(SRC $\{SRC\} $\{SRCROOT\}/ResourcePath.cpp)}
91 \textcolor{stringliteral}{    add\_executable($\{PROJECT\_NAME\} $\{INC\} $\{SRC\})}
92 \textcolor{stringliteral}{    # Add Links}
93 \textcolor{stringliteral}{        set(LIBS\_DIR $\{CMAKE\_CURRENT\_SOURCE\_DIR\}/extlibs/libs-msvc/$\{ARCH\}/libs)}
94 \textcolor{stringliteral}{        set(DEPENDENCIES\_DIR $\{CMAKE\_CURRENT\_SOURCE\_DIR\}/extlibs/libs-msvc/$\{ARCH\}/dlls)}
95 \textcolor{stringliteral}{    set(DEPENDENCIES\_TARGET\_DIR $<TARGET\_FILE\_DIR:$\{PROJECT\_NAME\}>)}
96 \textcolor{stringliteral}{    set(RESOURCES\_TARGET\_DIR $<TARGET\_FILE\_DIR:$\{PROJECT\_NAME\}>/Resources)}
97 \textcolor{stringliteral}{}
98 \textcolor{stringliteral}{elseif(APPLE)}
99 \textcolor{stringliteral}{    # Mac OS X Xcode}
100 \textcolor{stringliteral}{        set(CMAKE\_MACOSX\_RPATH 1)}
101 \textcolor{stringliteral}{    ADD\_DEFINITIONS(-std=c++11)}
102 \textcolor{stringliteral}{    }
103 \textcolor{stringliteral}{    # Add Source}
104 \textcolor{stringliteral}{    set(SRC $\{SRC\} $\{SRCROOT\}/ResourcePath.mm)}
105 \textcolor{stringliteral}{    add\_executable($\{PROJECT\_NAME\} MACOSX\_BUNDLE $\{INC\} $\{SRC\})}
106 \textcolor{stringliteral}{    # Add Links}
107 \textcolor{stringliteral}{    SET\_TARGET\_PROPERTIES($\{PROJECT\_NAME\} PROPERTIES}
108 \textcolor{stringliteral}{               XCODE\_ATTRIBUTE\_LD\_RUNPATH\_SEARCH\_PATHS @executable\_path/../Frameworks/)}
109 \textcolor{stringliteral}{    set(LIBS\_DIR $\{CMAKE\_CURRENT\_SOURCE\_DIR\}/extlibs/libs-osx)}
110 \textcolor{stringliteral}{    set(DEPENDENCIES\_DIR $\{LIBS\_DIR\})}
111 \textcolor{stringliteral}{    set(LIBS $\{LIBS\} SFML)}
112 \textcolor{stringliteral}{    set(DEPENDENCIES\_TARGET\_DIR $<TARGET\_FILE\_DIR:$\{PROJECT\_NAME\}>/../Frameworks)}
113 \textcolor{stringliteral}{    set(RESOURCES\_TARGET\_DIR $<TARGET\_FILE\_DIR:$\{PROJECT\_NAME\}>/../Resources)}
114 \textcolor{stringliteral}{else()}
115 \textcolor{stringliteral}{    # Unix}
116 \textcolor{stringliteral}{    ADD\_DEFINITIONS(-std=c++11)}
117 \textcolor{stringliteral}{    # Add Source}
118 \textcolor{stringliteral}{    set(SRC $\{SRC\} $\{SRCROOT\}/ResourcePath.cpp)}
119 \textcolor{stringliteral}{    add\_executable($\{PROJECT\_NAME\} $\{INC\} $\{SRC\})}
120 \textcolor{stringliteral}{    # Add Links}
121 \textcolor{stringliteral}{        set(LIBS\_DIR $\{CMAKE\_CURRENT\_SOURCE\_DIR\}/extlibs/libs-unix/$\{ARCH\})}
122 \textcolor{stringliteral}{        set(DEPENDENCIES\_DIR $\{LIBS\_DIR\})}
123 \textcolor{stringliteral}{    set(DEPENDENCIES\_TARGET\_DIR $<TARGET\_FILE\_DIR:$\{PROJECT\_NAME\}>)}
124 \textcolor{stringliteral}{    set(RESOURCES\_TARGET\_DIR $<TARGET\_FILE\_DIR:$\{PROJECT\_NAME\}>/Resources)}
125 \textcolor{stringliteral}{}
126 \textcolor{stringliteral}{endif()}
127 \textcolor{stringliteral}{}
128 \textcolor{stringliteral}{}
129 \textcolor{stringliteral}{foreach(LIB $\{LIBS\})}
130 \textcolor{stringliteral}{    find\_library(LIB\_$\{LIB\} NAMES $\{LIB\} PATHS $\{LIBS\_DIR\})}
131 \textcolor{stringliteral}{    target\_link\_libraries($\{PROJECT\_NAME\} $\{LIB\_$\{LIB\}\})}
132 \textcolor{stringliteral}{endforeach()}
133 \textcolor{stringliteral}{}
134 \textcolor{stringliteral}{set\_target\_properties(}
135 \textcolor{stringliteral}{    $\{PROJECT\_NAME\} PROPERTIES}
136 \textcolor{stringliteral}{    ARCHIVE\_OUTPUT\_DIRECTORY "}$\{CMAKE\_BINARY\_DIR\}/build\textcolor{stringliteral}{"}
137 \textcolor{stringliteral}{    LIBRARY\_OUTPUT\_DIRECTORY "}$\{CMAKE\_BINARY\_DIR\}/build\textcolor{stringliteral}{"}
138 \textcolor{stringliteral}{    RUNTIME\_OUTPUT\_DIRECTORY "}$\{CMAKE\_BINARY\_DIR\}/build\textcolor{stringliteral}{"}
139 \textcolor{stringliteral}{)}
140 \textcolor{stringliteral}{}
141 \textcolor{stringliteral}{# copy dependencies and resources}
142 \textcolor{stringliteral}{add\_custom\_command(TARGET $\{PROJECT\_NAME\} POST\_BUILD}
143 \textcolor{stringliteral}{                    COMMAND $\{CMAKE\_COMMAND\} -E copy\_directory}
144 \textcolor{stringliteral}{                    $\{DEPENDENCIES\_DIR\}}
145 \textcolor{stringliteral}{                    $\{DEPENDENCIES\_TARGET\_DIR\})}
146 \textcolor{stringliteral}{add\_custom\_command(TARGET $\{PROJECT\_NAME\} POST\_BUILD}
147 \textcolor{stringliteral}{                    COMMAND $\{CMAKE\_COMMAND\} -E copy\_directory}
148 \textcolor{stringliteral}{                    "}$\{PROJECT\_SOURCE\_DIR\}/resource\textcolor{stringliteral}{"}
149 \textcolor{stringliteral}{                    $\{RESOURCES\_TARGET\_DIR\})}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramBouncingCircleManager}{}\section{Bouncing\+Circle\+Manager}\label{_benchmark_program_BenchmarkProgramBouncingCircleManager}
\hypertarget{_benchmark_program_BenchmarkProgramBouncingCircleManager_h}{}\subsection{Bouncing\+Circle\+Manager.\+h}\label{_benchmark_program_BenchmarkProgramBouncingCircleManager_h}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/include/\+Bouncing\+Circle\+Manager.h} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  BouncingCircleManager.h}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 2/22/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#ifndef profiler\_BouncingCircleManager\_h}
10 \textcolor{preprocessor}{#define profiler\_BouncingCircleManager\_h}
11 
12 \textcolor{preprocessor}{#include "MyDSF.h"}
13 \textcolor{preprocessor}{#include "SyncBouncingCircle.h"}
14 \textcolor{preprocessor}{#include <yctools/Random.h>}
15 \textcolor{preprocessor}{#include <vector>}
16 
17 \textcolor{keyword}{class }BouncingCircleManager
18 \{
19 \textcolor{keyword}{public}:
20     BouncingCircleManager(MyDSF* dsf);
21     ~BouncingCircleManager();
22     MyDSF* dsf;
23     dsf::TaskFunction* create;
24     dsf::TaskFunction* update;
25     dsf::TaskFunction* destroy;
26     std::vector<SyncBouncingCircle*>* createRandomCircles(\textcolor{keywordtype}{int} number, \textcolor{keywordtype}{int} radius, \textcolor{keywordtype}{int} boundX, \textcolor{keywordtype}{int} boundY);
27 \textcolor{keyword}{private}:
28     SyncBouncingCircle* createRandomCircle(\textcolor{keywordtype}{int} radius, \textcolor{keywordtype}{int} boundX, \textcolor{keywordtype}{int} boundY);
29 \};
30 
31 
32 \textcolor{preprocessor}{#endif}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramBouncingCircleManager_cpp}{}\subsection{Bouncing\+Circle\+Manager.\+cpp}\label{_benchmark_program_BenchmarkProgramBouncingCircleManager_cpp}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/src/\+Bouncing\+Circle\+Manager.cpp} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  BouncingCircleManager.cpp}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 2/22/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#include "../include/BouncingCircleManager.h"}
10 \textcolor{preprocessor}{#include <cmath>}
11 
12 BouncingCircleManager::BouncingCircleManager(MyDSF* dsf)
13 \{
14     this->dsf = dsf;
15     this->create = \textcolor{keyword}{new} dsf::TaskFunction([\textcolor{keyword}{this}](dsf::SynchronizedObject* to, dsf::SynchronizedObject* from,
       dsf::TaskArgument* args)
16                                          \{
17                                              SyncBouncingCircle* syncObj;
18                                              std::vector<SyncBouncingCircle*>* syncObjs;
19                                              std::tie(syncObj, syncObjs) = args->to<
      std::tuple<SyncBouncingCircle*, std::vector<SyncBouncingCircle*>*>>();
20                                              \textcolor{keywordflow}{if}(this->dsf->window->isOpen())
21                                              \{
22                                                  this->dsf->send(to, from, this->update, \textcolor{keyword}{new} 
      dsf::TaskArgument(std::make\_tuple(syncObj, syncObjs)));
23                                                  this->dsf->lock();
24                                                  this->dsf->drawables->push\_back(syncObj);
25                                                  this->dsf->unlock();
26                                              \}
27                                              \textcolor{keywordflow}{else}
28                                              \{
29                                                  this->dsf->send(to, from, this->destroy, \textcolor{keyword}{new} 
      dsf::TaskArgument(syncObj));
30                                              \}
31                                          \});
32     this->update = \textcolor{keyword}{new} dsf::TaskFunction([\textcolor{keyword}{this}](dsf::SynchronizedObject* to, dsf::SynchronizedObject* from,
       dsf::TaskArgument* args)
33                                          \{
34                                              SyncBouncingCircle* syncObj;
35                                              std::vector<SyncBouncingCircle*>* syncObjs;
36                                              std::tie(syncObj, syncObjs) = args->to<
      std::tuple<SyncBouncingCircle*, std::vector<SyncBouncingCircle*>*>>();
37                                              \textcolor{keywordflow}{if}(this->dsf->window->isOpen())
38                                              \{
39                                                  \textcolor{keyword}{auto} size = this->dsf->window->getSize();
40                                                  \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} & sb : *syncObjs)
41                                                  \{
42                                                      \textcolor{keywordflow}{if}(sb != syncObj)
43                                                          syncObj->collide(sb);
44                                                  \}
45                                                  syncObj->move(size.x, size.y);
46                                                  this->dsf->send(to, from, this->update, \textcolor{keyword}{new} 
      dsf::TaskArgument(std::make\_tuple(syncObj, syncObjs)));
47                                              \}
48                                              \textcolor{keywordflow}{else}
49                                              \{
50                                                  this->dsf->send(to, from, this->destroy, \textcolor{keyword}{new} 
      dsf::TaskArgument(syncObj));
51                                              \}
52                                          \});
53     this->destroy = \textcolor{keyword}{new} dsf::TaskFunction([\textcolor{keyword}{this}](dsf::SynchronizedObject* to, dsf::SynchronizedObject* from
      , dsf::TaskArgument* args)
54                                           \{
55                                               \textcolor{keyword}{auto} syncObj = args->to<SyncBouncingCircle*>();
56                                               \textcolor{keyword}{auto} drawable = (sf::Drawable*) syncObj;
57                                               this->dsf->lock();
58                                               this->dsf->drawables->erase(
59                                                                           std::remove\_if(
60                                                                                          this->dsf->
      drawables->begin(),
61                                                                                          this->dsf->
      drawables->end(),
62                                                                                          [&](sf::Drawable* 
      d)
63                                                                                          \{
64                                                                                              \textcolor{keywordflow}{return} d == 
      drawable;
65                                                                                          \}),
66                                                                           this->dsf->drawables->end());
67                                               this->dsf->remove(to);
68                                               this->dsf->unlock();
69                                           \});
70 \}
71 BouncingCircleManager::~BouncingCircleManager()
72 \{
73     \textcolor{keyword}{delete} this->create;
74     \textcolor{keyword}{delete} this->update;
75     \textcolor{keyword}{delete} this->destroy;
76 \}
77 
78 std::vector<SyncBouncingCircle*>* BouncingCircleManager::createRandomCircles(\textcolor{keywordtype}{int} number, \textcolor{keywordtype}{int} radius, \textcolor{keywordtype}{int} 
      boundX, \textcolor{keywordtype}{int} boundY) \{
79     \textcolor{keywordtype}{int} numberOfCircles = number;
80     \textcolor{keyword}{auto} circles = \textcolor{keyword}{new} std::vector<SyncBouncingCircle*>();
81     SyncBouncingCircle* circle;
82     \textcolor{keywordflow}{while}(circles->size() < numberOfCircles) \{
83         std::vector<SyncBouncingCircle*>::iterator itr = circles->begin();
84         circle = createRandomCircle(radius, boundX, boundY);
85         \textcolor{keywordflow}{while} (itr != circles->end()) \{
86             \textcolor{keywordflow}{if} (circle->hasCollision(*itr)) \{
87                 \textcolor{keyword}{delete} circle;
88                 circle = createRandomCircle(radius, boundX, boundY);
89                 itr = circles->begin();
90             \} \textcolor{keywordflow}{else} \{
91                 itr ++;
92             \}
93         \}
94         circles->push\_back(circle);
95     \}
96     \textcolor{keywordflow}{return} circles;
97 \}
98 
99 SyncBouncingCircle*  BouncingCircleManager::createRandomCircle(\textcolor{keywordtype}{int} radius, \textcolor{keywordtype}{int} boundX, \textcolor{keywordtype}{int} boundY) \{
100     SyncBouncingCircle* circle = \textcolor{keyword}{new} SyncBouncingCircle();
101     \textcolor{keywordtype}{int} direction = yc::Random().randInt(1, 360);
102     \textcolor{keywordtype}{int} posx = yc::Random().randInt(0, boundX - radius * 2);
103     \textcolor{keywordtype}{int} posy = yc::Random().randInt(0, boundY - radius * 2);
104     \textcolor{keywordtype}{float} x = cosf(direction * M\_PI / 180);
105     \textcolor{keywordtype}{float} y = sinf(direction * M\_PI / 180);
106     circle->setRadius(radius);
107     circle->setPosition(sf::Vector2<float>(posx, posy));
108     circle->setVelocity(sf::Vector2<float>(x, y));
109     \textcolor{keywordflow}{return} circle;
110 \}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramDSFSFML}{}\section{D\+S\+F\+S\+F\+M\+L}\label{_benchmark_program_BenchmarkProgramDSFSFML}
\hypertarget{_benchmark_program_BenchmarkProgramDSFSFML_h}{}\subsection{D\+S\+F\+S\+F\+M\+L.\+h}\label{_benchmark_program_BenchmarkProgramDSFSFML_h}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/include/\+D\+S\+F\+S\+F\+M\+L.h} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  DSFSFML.h}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 2/16/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#ifndef profiler\_DSFSFML\_h}
10 \textcolor{preprocessor}{#define profiler\_DSFSFML\_h}
11 
12 \textcolor{preprocessor}{#include <SFML/Graphics.hpp>}
13 \textcolor{preprocessor}{#include <vector>}
14 
15 \textcolor{keyword}{namespace }dsf
16 \{
17     \textcolor{keyword}{namespace }sfml
18     \{
19         \textcolor{keyword}{class }RenderWindow
20         \{
21         \textcolor{keyword}{public}:
22             \textcolor{keyword}{explicit} RenderWindow();
23             \textcolor{keyword}{virtual} ~RenderWindow();
24             sf::RenderWindow* window;
25             std::vector<sf::Drawable*>* drawables;
26         \textcolor{keyword}{protected}:
27             \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} draw() = 0;
28         \};
29     \}
30 \}
31 \textcolor{preprocessor}{#endif}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramDSFSFML_cpp}{}\subsection{D\+S\+F\+S\+F\+M\+L.\+cpp}\label{_benchmark_program_BenchmarkProgramDSFSFML_cpp}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/src/\+D\+S\+F\+S\+F\+M\+L.cpp} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  DSFSFML.cpp}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 2/17/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#include "../include/DSFSFML.h"}
10 
11 \textcolor{keyword}{namespace }dsf
12 \{
13     \textcolor{keyword}{namespace }sfml
14     \{
15         RenderWindow::RenderWindow()
16         \{
17             this->window = \textcolor{keyword}{new} sf::RenderWindow();
18             this->drawables = \textcolor{keyword}{new} std::vector<sf::Drawable*>();
19         \}
20 
21         RenderWindow::~RenderWindow()
22         \{
23             \textcolor{keyword}{delete} this->window;
24             \textcolor{keyword}{delete} this->drawables;
25         \}
26     \}
27 \}
28 
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramFlockingBoidManager}{}\section{Flocking\+Boid\+Manager}\label{_benchmark_program_BenchmarkProgramFlockingBoidManager}
\hypertarget{_benchmark_program_BenchmarkProgramFlockingBoidManager_h}{}\subsection{Flocking\+Boid\+Manager.\+h}\label{_benchmark_program_BenchmarkProgramFlockingBoidManager_h}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/include/\+Flocking\+Boid\+Manager.h} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  FlockingBoidManager.h}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 3/12/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#ifndef profiler\_FlockingBoidManager\_h}
10 \textcolor{preprocessor}{#define profiler\_FlockingBoidManager\_h}
11 
12 \textcolor{preprocessor}{#include "MyDSF.h"}
13 \textcolor{preprocessor}{#include "SyncFlockingBoid.h"}
14 \textcolor{preprocessor}{#include <yctools/Random.h>}
15 \textcolor{preprocessor}{#include <vector>}
16 
17 \textcolor{keyword}{class }FlockingBoidManager
18 \{
19 \textcolor{keyword}{public}:
20     FlockingBoidManager(MyDSF* dsf);
21     ~FlockingBoidManager();
22     MyDSF* dsf;
23     dsf::TaskFunction* create;
24     dsf::TaskFunction* update;
25     dsf::TaskFunction* destroy;
26 \};
27 
28 \textcolor{preprocessor}{#endif}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramFlockingBoidManager_cpp}{}\subsection{Flocking\+Boid\+Manager.\+cpp}\label{_benchmark_program_BenchmarkProgramFlockingBoidManager_cpp}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/src/\+Flocking\+Boid\+Manager.cpp} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  FlockingBoidManager.cpp}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 3/12/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#include "../include/FlockingBoidManager.h"}
10 
11 
12 FlockingBoidManager::FlockingBoidManager(MyDSF* dsf)
13 \{
14     this->dsf = dsf;
15     this->create = \textcolor{keyword}{new} dsf::TaskFunction([\textcolor{keyword}{this}](dsf::SynchronizedObject* to, dsf::SynchronizedObject* from,
       dsf::TaskArgument* args)
16                                          \{
17                                              SyncFlockingBoid* syncObj;
18                                              std::vector<SyncFlockingBoid*>* syncObjs;
19                                              std::tie(syncObj, syncObjs) = args->to<
      std::tuple<SyncFlockingBoid*, std::vector<SyncFlockingBoid*>*>>();
20                                              \textcolor{keywordflow}{if}(this->dsf->window->isOpen())
21                                              \{
22                                                  this->dsf->send(to, from, this->update, \textcolor{keyword}{new} 
      dsf::TaskArgument(std::make\_tuple(syncObj, syncObjs)));
23                                                  this->dsf->lock();
24                                                  this->dsf->drawables->push\_back(syncObj);
25                                                  this->dsf->unlock();
26                                              \}
27                                              \textcolor{keywordflow}{else}
28                                              \{
29                                                  this->dsf->send(to, from, this->destroy, \textcolor{keyword}{new} 
      dsf::TaskArgument(syncObj));
30                                              \}
31                                          \});
32     this->update = \textcolor{keyword}{new} dsf::TaskFunction([\textcolor{keyword}{this}](dsf::SynchronizedObject* to, dsf::SynchronizedObject* from,
       dsf::TaskArgument* args)
33                                          \{
34                                              SyncFlockingBoid* syncObj;
35                                              std::vector<SyncFlockingBoid*>* syncObjs;
36                                              std::tie(syncObj, syncObjs) = args->to<
      std::tuple<SyncFlockingBoid*, std::vector<SyncFlockingBoid*>*>>();
37                                              \textcolor{keywordflow}{if}(this->dsf->window->isOpen())
38                                              \{
39                                                  syncObj->run(syncObjs, this->dsf->window);
40                                                  this->dsf->send(to, from, this->update, \textcolor{keyword}{new} 
      dsf::TaskArgument(std::make\_tuple(syncObj, syncObjs)));
41                                              \}
42                                              \textcolor{keywordflow}{else}
43                                              \{
44                                                  this->dsf->send(to, from, this->destroy, \textcolor{keyword}{new} 
      dsf::TaskArgument(syncObj));
45                                              \}
46                                          \});
47     this->destroy = \textcolor{keyword}{new} dsf::TaskFunction([\textcolor{keyword}{this}](dsf::SynchronizedObject* to, dsf::SynchronizedObject* from
      , dsf::TaskArgument* args)
48                                           \{
49                                               \textcolor{keyword}{auto} syncObj = args->to<SyncFlockingBoid*>();
50                                               \textcolor{keyword}{auto} drawable = (sf::Drawable*) syncObj;
51                                               this->dsf->lock();
52                                               this->dsf->drawables->erase(
53                                                                           std::remove\_if(
54                                                                                          this->dsf->
      drawables->begin(),
55                                                                                          this->dsf->
      drawables->end(),
56                                                                                          [&](sf::Drawable* 
      d)
57                                                                                          \{
58                                                                                              \textcolor{keywordflow}{return} d == 
      drawable;
59                                                                                          \}),
60                                                                           this->dsf->drawables->end());
61                                               this->dsf->remove(to);
62                                               this->dsf->unlock();
63                                           \});
64 \}
65 FlockingBoidManager::~FlockingBoidManager()
66 \{
67     \textcolor{keyword}{delete} this->create;
68     \textcolor{keyword}{delete} this->update;
69     \textcolor{keyword}{delete} this->destroy;
70 \}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramFPS}{}\section{F\+P\+S}\label{_benchmark_program_BenchmarkProgramFPS}
\hypertarget{_benchmark_program_BenchmarkProgramFPS_h}{}\subsection{F\+P\+S.\+h}\label{_benchmark_program_BenchmarkProgramFPS_h}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/include/\+F\+P\+S.h} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  FPS.h}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 2/8/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#ifndef profiler\_FPS\_h}
10 \textcolor{preprocessor}{#define profiler\_FPS\_h}
11 
12 \textcolor{preprocessor}{#include <SFML/Graphics.hpp>}
13 
14 \textcolor{keyword}{class }FPS
15 \{
16 \textcolor{keyword}{public}:
17     FPS(\textcolor{keywordtype}{float} refreshTime = 1.0, \textcolor{keywordtype}{float} startTime = 1.0);
18     ~FPS();
19     \textcolor{keywordtype}{void} refresh();
20     \textcolor{keywordtype}{void} restart();
21     \textcolor{keywordtype}{float} current;
22     \textcolor{keywordtype}{float} average;
23     \textcolor{keywordtype}{float} max;
24     \textcolor{keywordtype}{float} min;
25 \textcolor{keyword}{private}:
26     \textcolor{keywordtype}{bool} started;
27     \textcolor{keywordtype}{float} refreshTime;
28     \textcolor{keywordtype}{float} startTime;
29     sf::Clock clock;
30     sf::Clock clockFps;
31     sf::Clock clockStart;
32     \textcolor{keywordtype}{float} temp;
33 \};
34 
35 \textcolor{preprocessor}{#endif}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramFPS_cpp}{}\subsection{F\+P\+S.\+cpp}\label{_benchmark_program_BenchmarkProgramFPS_cpp}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/src/\+F\+P\+S.cpp} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  FPS.cpp}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 2/8/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#include "../include/FPS.h"}
10 
11 FPS::FPS(\textcolor{keywordtype}{float} refreshTime, \textcolor{keywordtype}{float} startTime)
12 \{
13     this->refreshTime = refreshTime;
14     this->startTime = startTime;
15 \}
16 
17 FPS::~FPS()
18 \{
19     
20 \}
21 
22 \textcolor{keywordtype}{void} FPS::refresh()
23 \{
24     \textcolor{keywordflow}{if}(started)
25     \{
26         \textcolor{keywordflow}{if}(!this->temp)
27             this->temp = 1.0f / this->clockFps.getElapsedTime().asSeconds();
28         \textcolor{keywordflow}{else}
29             this->temp = (this->temp + 1.0f / this->clockFps.getElapsedTime().asSeconds()) / 2.0f;
30         this->clockFps.restart();
31         \textcolor{keywordflow}{if}(this->clock.getElapsedTime().asSeconds() >= refreshTime)
32         \{
33             this->current = this->temp;
34             this->temp = 0;
35             \textcolor{keywordflow}{if}(this->average)
36                 this->average = (this->average + this->current) / 2.0f;
37             \textcolor{keywordflow}{else}
38                 this->average = this->current;
39             \textcolor{keywordflow}{if}(!this->max || this->max < this->current)
40                 this->max = this->current;
41             \textcolor{keywordflow}{if}(!this->min || this->min > this->current)
42                 this->min = this->current;
43             
44             this->clock.restart();
45         \}
46     \}
47     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(this->clockStart.getElapsedTime().asSeconds() >= startTime)
48     \{
49         this->started = \textcolor{keyword}{true};
50         this->clock.restart();
51         this->clockFps.restart();
52         this->current = this->average = this->max = this->min = this->temp = 0;
53     \}
54 \}
55 
56 \textcolor{keywordtype}{void} FPS::restart()
57 \{
58     this->clockStart.restart();
59     this->started = \textcolor{keyword}{false};
60     this->current = this->average = this->max = this->min = this->temp = 0;
61 \}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramMyDSF}{}\section{My\+D\+S\+F}\label{_benchmark_program_BenchmarkProgramMyDSF}
\hypertarget{_benchmark_program_BenchmarkProgramMyDSF_h}{}\subsection{My\+D\+S\+F.\+h}\label{_benchmark_program_BenchmarkProgramMyDSF_h}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/include/\+My\+D\+S\+F.h} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  MyDSF.h}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 2/8/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#ifndef profiler\_MyDSF\_h}
10 \textcolor{preprocessor}{#define profiler\_MyDSF\_h}
11 
12 \textcolor{preprocessor}{#include <dsf/DualStateFramework.h>}
13 \textcolor{preprocessor}{#include <dsf/TaskFunction.h>}
14 \textcolor{preprocessor}{#include <dsf/Lock.h>}
15 \textcolor{preprocessor}{#include "DSFSFML.h"}
16 \textcolor{preprocessor}{#include "FPS.h"}
17 \textcolor{preprocessor}{#include "ResourcePath.hpp"}
18 
19 \textcolor{keyword}{class }MyDSF : \textcolor{keyword}{public} dsf::DualStateFramework, \textcolor{keyword}{public} dsf::sfml::RenderWindow, \textcolor{keyword}{public} dsf::Lock
20 \{
21 \textcolor{keyword}{private}:
22     \textcolor{keyword}{class }Sender;
23     FPS* fps;
24     std::vector<std::tuple<float,float,float>> fpsList;
25     sf::Clock* clock;
26     sf::Font font;
27     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} numberOfCores = 1;
28     std::vector<std::tuple<float,float,float>> stretch(std::vector<std::tuple<float,float,float>> arr,
29                                                        std::vector<std::tuple<float,float,float>> strelen,
30                                                        \textcolor{keywordtype}{int} maxLen);
31 \textcolor{keyword}{public}:
32     MyDSF();
33     ~MyDSF();
34     \textcolor{keywordtype}{void} initialize() \textcolor{keyword}{override};
35     Sender* sender;
36     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} duration = 10;
37     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} maxNumberOfCores = 8;
38 \textcolor{keyword}{protected}:
39     \textcolor{keywordtype}{void} refresh() \textcolor{keyword}{override};
40     \textcolor{keywordtype}{void} run() \textcolor{keyword}{override};
41     \textcolor{keywordtype}{void} draw() \textcolor{keyword}{override};
42 \};
43 
44 \textcolor{keyword}{class }MyDSF::Sender : \textcolor{keyword}{public} dsf::SynchronizedObject
45 \{
46 \textcolor{keyword}{public}:
47     Sender(dsf::DualStateFramework* dsf);
48     ~Sender();
49     dsf::DualStateFramework* dsf;
50     dsf::TaskFunction* create;
51     dsf::TaskFunction* update;
52     dsf::TaskFunction* destroy;
53 \textcolor{keyword}{protected}:
54     \textcolor{keywordtype}{void} run() \textcolor{keyword}{override};
55 \};
56 
57 
58 \textcolor{preprocessor}{#endif}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramMyDSF_cpp}{}\subsection{My\+D\+S\+F.\+cpp}\label{_benchmark_program_BenchmarkProgramMyDSF_cpp}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/src/\+My\+D\+S\+F.cpp} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  MyDSF.cpp}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 2/8/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#include "../include/MyDSF.h"}
10 \textcolor{preprocessor}{#include "../include/FPS.h"}
11 \textcolor{preprocessor}{#include <dsf/TaskArgument.h>}
12 \textcolor{preprocessor}{#include <SFML/Graphics.hpp>}
13 \textcolor{preprocessor}{#include <iostream>}
14 \textcolor{preprocessor}{#include <yctools/Random.h>}
15 
16 MyDSF::MyDSF()
17 : DualStateFramework()
18 \{
19     this->initialize();
20 \}
21 MyDSF::~MyDSF()
22 \{
23     \textcolor{keyword}{delete} this->fps;
24     \textcolor{keyword}{delete} this->clock;
25 \}
26 
27 \textcolor{keywordtype}{void} MyDSF::initialize()
28 \{
29     this->sender = \textcolor{keyword}{new} Sender(\textcolor{keyword}{this});
30     this->fps = \textcolor{keyword}{new} FPS();
31     this->clock = \textcolor{keyword}{new} sf::Clock();
32     this->add(this->sender);
33     this->send(this->sender, this->sender, this->sender->create, \textcolor{keyword}{new} dsf::TaskArgument((
      dsf::sfml::RenderWindow*)\textcolor{keyword}{this}));
34     this->window->create(sf::VideoMode(800, 600), \textcolor{stringliteral}{"DSF Profiler"});
35     this->setNumberOfThreads(numberOfCores);
36     this->font.loadFromFile(resourcePath() + \textcolor{stringliteral}{"sansation.ttf"});
37 \}
38 
39 \textcolor{keywordtype}{void} MyDSF::refresh()
40 \{
41     dsf::DualStateFramework::refresh();
42 \}
43 
44 \textcolor{keywordtype}{void} MyDSF::run()
45 \{
46     \textcolor{keywordflow}{if}(this->numberOfCores <= this->maxNumberOfCores
47        && this->clock->getElapsedTime().asSeconds() >= this->duration)
48     \{
49         this->fpsList.push\_back(std::make\_tuple(this->fps->average,
50                                                 this->fps->min,
51                                                 this->fps->max));
52         this->clock->restart();
53         this->fps->restart();
54         this->numberOfCores ++;
55         this->setNumberOfThreads(this->numberOfCores);
56     \}
57     dsf::DualStateFramework::run();
58     \textcolor{keywordflow}{if} (this->window->isOpen())
59     \{
60         sf::Event event;
61         \textcolor{keywordflow}{while} (this->window->pollEvent(event))
62         \{
63             \textcolor{keywordflow}{if} (event.type == sf::Event::Closed)
64             \{
65                 this->window->close();
66             \}
67         \}
68         this->window->clear();
69         this->draw();
70         this->fps->refresh();
71         \textcolor{keywordflow}{if}(this->numberOfCores <= this->maxNumberOfCores)
72         \{
73             \textcolor{keywordflow}{if}(this->fps->current)
74             \{
75                 std::string msg = \textcolor{stringliteral}{"Number of Core: "} + std::to\_string(this->numberOfCores) + \textcolor{stringliteral}{"\(\backslash\)n"};
76                 msg += \textcolor{stringliteral}{"FPS \(\backslash\)n"};
77                 msg += \textcolor{stringliteral}{" Current: "} + std::to\_string(fps->current) + \textcolor{stringliteral}{"\(\backslash\)n"};
78                 msg += \textcolor{stringliteral}{" Average: "} + std::to\_string(fps->average) + \textcolor{stringliteral}{"\(\backslash\)n"};
79                 msg += \textcolor{stringliteral}{" Min: "} + std::to\_string(fps->min) + \textcolor{stringliteral}{"\(\backslash\)n"};
80                 msg += \textcolor{stringliteral}{" Max: "} + std::to\_string(fps->max);
81                 sf::Text text(msg, font);
82                 this->window->draw(text);
83             \}
84         \}
85         \textcolor{keywordflow}{else}
86         \{
87             \textcolor{keyword}{const} \textcolor{keywordtype}{float} width = 700;
88             \textcolor{keyword}{const} \textcolor{keywordtype}{float} height = 500;
89             \textcolor{keyword}{const} sf::Vector2<float> origin(50, 550);
90             \textcolor{keyword}{const} \textcolor{keywordtype}{float} thickness = 3;
91             \textcolor{keyword}{const} \textcolor{keywordtype}{float} barThickness = 10;
92             sf::RectangleShape x(sf::Vector2<float>(width, thickness));
93             sf::RectangleShape y(sf::Vector2<float>(thickness, height));
94             sf::RectangleShape fill(sf::Vector2<float>(thickness, thickness));
95             x.setPosition(origin);
96             y.setPosition(origin);
97             fill.setPosition(origin - sf::Vector2<float>(thickness, 0));
98             y.rotate(180);
99             this->window->draw(x);
100             this->window->draw(y);
101             this->window->draw(fill);
102             \textcolor{keyword}{auto} bars = stretch(this->fpsList, this->fpsList, height);
103             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < this->fpsList.size(); i ++)
104             \{
105                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} charSize = 12;
106                 \textcolor{keywordtype}{float} x = width / (this->fpsList.size() + 1) * (i + 1);
107                 \textcolor{keywordtype}{float} average;
108                 \textcolor{keywordtype}{float} min;
109                 \textcolor{keywordtype}{float} max;
110                 \textcolor{keywordtype}{float} averageBar;
111                 \textcolor{keywordtype}{float} minBar;
112                 \textcolor{keywordtype}{float} maxBar;
113                 std::tie(averageBar, minBar, maxBar) = bars[i];
114                 std::tie(average, min, max) = this->fpsList[i];
115                 sf::RectangleShape bar(sf::Vector2<float>(barThickness, maxBar - minBar));
116                 bar.setPosition(origin + sf::Vector2<float>(x, -minBar));
117                 bar.rotate(180);
118                 sf::Text textAverage(std::to\_string(average), this->font);
119                 textAverage.setCharacterSize(charSize);
120                 textAverage.setPosition(origin + sf::Vector2<float>(x, -averageBar));
121                 sf::Text textMin(std::to\_string(min), this->font);
122                 textMin.setCharacterSize(charSize);
123                 textMin.setPosition(origin + sf::Vector2<float>(x, -minBar));
124                 sf::Text textMax(std::to\_string(max), this->font);
125                 textMax.setCharacterSize(charSize);
126                 textMax.setPosition(origin + sf::Vector2<float>(x, -maxBar));
127                 sf::Text textCore(std::to\_string(i + 1), this->font);
128                 textCore.setCharacterSize(14);
129                 textCore.setPosition(origin + sf::Vector2<float>(x, 0));
130                 this->window->draw(bar);
131                 this->window->draw(textAverage);
132                 this->window->draw(textMin);
133                 this->window->draw(textMax);
134                 this->window->draw(textCore);
135             \}
136         \}
137         this->window->display();
138     \}
139 \}
140 
141 \textcolor{keywordtype}{void} MyDSF::draw()
142 \{
143     std::for\_each(this->drawables->begin(), this->drawables->end(), [\textcolor{keyword}{this}](sf::Drawable* drawable)
144                   \{
145                       this->window->draw(*drawable);
146                   \});
147 \}
148 
149 MyDSF::Sender::Sender(dsf::DualStateFramework* dsf)  : SynchronizedObject()
150 \{
151     this->dsf = dsf;
152     this->create = \textcolor{keyword}{new} dsf::TaskFunction([\textcolor{keyword}{this}](dsf::SynchronizedObject* to, dsf::SynchronizedObject* from,
       dsf::TaskArgument* args)
153                                          \{
154                                              \textcolor{keyword}{auto} rw = args->to<dsf::sfml::RenderWindow*>();
155                                              \textcolor{keywordflow}{if}(rw->window->isOpen())
156                                              \{
157                                                  this->dsf->send(to, from, this->update, \textcolor{keyword}{new} 
      dsf::TaskArgument(rw));
158                                              \}
159                                              \textcolor{keywordflow}{else}
160                                              \{
161                                                  this->dsf->send(to, from, this->destroy, \textcolor{keyword}{nullptr});
162                                              \}
163                                          \});
164     this->update = \textcolor{keyword}{new} dsf::TaskFunction([\textcolor{keyword}{this}](dsf::SynchronizedObject* to, dsf::SynchronizedObject* from,
       dsf::TaskArgument* args)
165                                          \{
166                                              \textcolor{keyword}{auto} rw = args->to<dsf::sfml::RenderWindow*>();
167                                              \textcolor{keywordflow}{if}(rw->window->isOpen())
168                                              \{
169                                                  this->dsf->send(to, from, this->update, \textcolor{keyword}{new} 
      dsf::TaskArgument(rw));
170                                              \}
171                                              \textcolor{keywordflow}{else}
172                                              \{
173                                                  this->dsf->send(to, from, this->destroy, \textcolor{keyword}{nullptr});
174                                              \}
175                                          \});
176     this->destroy = \textcolor{keyword}{new} dsf::TaskFunction([\textcolor{keyword}{this}](dsf::SynchronizedObject* to, dsf::SynchronizedObject* from
      , dsf::TaskArgument* args)
177                                           \{
178                                               this->dsf->remove(to);
179                                           \});
180 \}
181 
182 MyDSF::Sender::~Sender()
183 \{
184     \textcolor{keyword}{delete} this->create;
185     \textcolor{keyword}{delete} this->update;
186     \textcolor{keyword}{delete} this->destroy;
187 \}
188 
189 \textcolor{keywordtype}{void} MyDSF::Sender::run()
190 \{
191     \textcolor{keywordflow}{if}(this->receive())
192         this->process();
193 \}
194 
195 std::vector<std::tuple<float,float,float>> MyDSF::stretch(std::vector<std::tuple<float,float,float>> arr,
196                                                    std::vector<std::tuple<float,float,float>> strelen,
197                                                    \textcolor{keywordtype}{int} maxLen)
198 \{
199     \textcolor{keywordtype}{bool} canDouble = \textcolor{keyword}{true};
200     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < arr.size(); i ++)
201     \{
202         \textcolor{keywordtype}{float} average;
203         \textcolor{keywordtype}{float} min;
204         \textcolor{keywordtype}{float} max;
205         \textcolor{keywordtype}{float} averageOrigin;
206         \textcolor{keywordtype}{float} minOrigin;
207         \textcolor{keywordtype}{float} maxOrigin;
208         std::tie(average, min, max) = arr[i];
209         std::tie(averageOrigin, minOrigin, maxOrigin) = strelen[i];
210         \textcolor{keywordflow}{if}(max + maxOrigin > maxLen)
211         \{
212             canDouble = \textcolor{keyword}{false};
213             \textcolor{keywordflow}{break};
214         \}
215     \}
216     \textcolor{keywordflow}{if}(canDouble)
217     \{
218         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < arr.size(); i ++)
219         \{
220             \textcolor{keywordtype}{float} average;
221             \textcolor{keywordtype}{float} min;
222             \textcolor{keywordtype}{float} max;
223             \textcolor{keywordtype}{float} averageOrigin;
224             \textcolor{keywordtype}{float} minOrigin;
225             \textcolor{keywordtype}{float} maxOrigin;
226             std::tie(average, min, max) = arr[i];
227             std::tie(averageOrigin, minOrigin, maxOrigin) = strelen[i];
228             arr[i] = std::make\_tuple(average + averageOrigin,
229                                      min + minOrigin,
230                                      max + maxOrigin);
231         \}
232         \textcolor{keywordflow}{return} stretch(arr, strelen, maxLen);
233     \}
234     \textcolor{keywordflow}{return} arr;
235 \}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramRandomCircleManager}{}\section{Random\+Circle\+Manager}\label{_benchmark_program_BenchmarkProgramRandomCircleManager}
\hypertarget{_benchmark_program_BenchmarkProgramRandomCircleManager_h}{}\subsection{Random\+Circle\+Manager.\+h}\label{_benchmark_program_BenchmarkProgramRandomCircleManager_h}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/include/\+Random\+Circle\+Manager.h} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  RandomCircleManager.h}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 2/21/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#ifndef profiler\_RandomCircleManager\_h}
10 \textcolor{preprocessor}{#define profiler\_RandomCircleManager\_h}
11 
12 \textcolor{preprocessor}{#include "MyDSF.h"}
13 \textcolor{preprocessor}{#include "SyncCircle.h"}
14 \textcolor{preprocessor}{#include <yctools/Random.h>}
15 
16 \textcolor{keyword}{class }RandomCircleManager
17 \{
18 \textcolor{keyword}{public}:
19     RandomCircleManager(MyDSF* dsf);
20     ~RandomCircleManager();
21     MyDSF* dsf;
22     dsf::TaskFunction* create;
23     dsf::TaskFunction* update;
24     dsf::TaskFunction* destroy;
25 \};
26 
27 \textcolor{preprocessor}{#endif}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramRandomCircleManager_cpp}{}\subsection{Random\+Circle\+Manager.\+cpp}\label{_benchmark_program_BenchmarkProgramRandomCircleManager_cpp}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/src/\+Random\+Circle\+Manager.cpp} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  RandomCircleManager.cpp}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 2/21/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#include "../include/RandomCircleManager.h"}
10 
11 RandomCircleManager::RandomCircleManager(MyDSF* dsf)
12 \{
13     this->dsf = dsf;
14     this->create = \textcolor{keyword}{new} dsf::TaskFunction([\textcolor{keyword}{this}](dsf::SynchronizedObject* to, dsf::SynchronizedObject* from,
       dsf::TaskArgument* args)
15                                          \{
16                                              \textcolor{keyword}{auto} syncObj = args->to<SyncCircle*>();
17                                              \textcolor{keywordflow}{if}(this->dsf->window->isOpen())
18                                              \{
19                                                  this->dsf->send(to, from, this->update, \textcolor{keyword}{new} 
      dsf::TaskArgument(syncObj));
20                                                  this->dsf->lock();
21                                                  this->dsf->drawables->push\_back(syncObj);
22                                                  this->dsf->unlock();
23                                              \}
24                                              \textcolor{keywordflow}{else}
25                                              \{
26                                                  this->dsf->send(to, from, this->destroy, \textcolor{keyword}{new} 
      dsf::TaskArgument(syncObj));
27                                              \}
28                                          \});
29     this->update = \textcolor{keyword}{new} dsf::TaskFunction([\textcolor{keyword}{this}](dsf::SynchronizedObject* to, dsf::SynchronizedObject* from,
       dsf::TaskArgument* args)
30                                          \{
31                                              \textcolor{keyword}{auto} syncObj = args->to<SyncCircle*>();
32                                              \textcolor{keywordflow}{if}(this->dsf->window->isOpen())
33                                              \{
34                                                  \textcolor{keyword}{auto} size = this->dsf->window->getSize();
35                                                  \textcolor{keyword}{auto} radius = syncObj->getRadius();
36                                                  syncObj->setPosition(
37                                                                       yc::Random().randInt(0, size.x - 2 * 
      radius),
38                                                                       yc::Random().randInt(0, size.y - 2 * 
      radius)
39                                                                       );
40                                                  this->dsf->send(to, from, this->update, \textcolor{keyword}{new} 
      dsf::TaskArgument(syncObj));
41                                              \}
42                                              \textcolor{keywordflow}{else}
43                                              \{
44                                                  this->dsf->send(to, from, this->destroy, \textcolor{keyword}{new} 
      dsf::TaskArgument(syncObj));
45                                              \}
46                                          \});
47     this->destroy = \textcolor{keyword}{new} dsf::TaskFunction([\textcolor{keyword}{this}](dsf::SynchronizedObject* to, dsf::SynchronizedObject* from
      , dsf::TaskArgument* args)
48                                           \{
49                                               \textcolor{keyword}{auto} syncObj = args->to<SyncCircle*>();
50                                               \textcolor{keyword}{auto} drawable = (sf::Drawable*) syncObj;
51                                               this->dsf->lock();
52                                               this->dsf->drawables->erase(
53                                                                           std::remove\_if(
54                                                                                          this->dsf->
      drawables->begin(),
55                                                                                          this->dsf->
      drawables->end(),
56                                                                                          [&](sf::Drawable* 
      d)
57                                                                                          \{
58                                                                                              \textcolor{keywordflow}{return} d == 
      drawable;
59                                                                                          \}),
60                                                                           this->dsf->drawables->end());
61                                               this->dsf->remove(to);
62                                               this->dsf->unlock();
63                                           \});
64 \}
65 RandomCircleManager::~RandomCircleManager()
66 \{
67     \textcolor{keyword}{delete} this->create;
68     \textcolor{keyword}{delete} this->update;
69     \textcolor{keyword}{delete} this->destroy;
70 \}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramResourcePath}{}\section{Resource\+Path}\label{_benchmark_program_BenchmarkProgramResourcePath}
\hypertarget{_benchmark_program_BenchmarkProgramResourcePath_h}{}\subsection{Resource\+Path.\+hpp}\label{_benchmark_program_BenchmarkProgramResourcePath_h}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/include/\+Resource\+Path.hpp} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
3 \textcolor{comment}{// SFML - Simple and Fast Multimedia Library}
4 \textcolor{comment}{// Copyright (C) 2007-2013 Marco Antognini (antognini.marco@gmail.com),}
5 \textcolor{comment}{//                         Laurent Gomila (laurent.gom@gmail.com),}
6 \textcolor{comment}{//}
7 \textcolor{comment}{// This software is provided 'as-is', without any express or implied warranty.}
8 \textcolor{comment}{// In no event will the authors be held liable for any damages arising from the use of this software.}
9 \textcolor{comment}{//}
10 \textcolor{comment}{// Permission is granted to anyone to use this software for any purpose,}
11 \textcolor{comment}{// including commercial applications, and to alter it and redistribute it freely,}
12 \textcolor{comment}{// subject to the following restrictions:}
13 \textcolor{comment}{//}
14 \textcolor{comment}{// 1. The origin of this software must not be misrepresented;}
15 \textcolor{comment}{//    you must not claim that you wrote the original software.}
16 \textcolor{comment}{//    If you use this software in a product, an acknowledgment}
17 \textcolor{comment}{//    in the product documentation would be appreciated but is not required.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// 2. Altered source versions must be plainly marked as such,}
20 \textcolor{comment}{//    and must not be misrepresented as being the original software.}
21 \textcolor{comment}{//}
22 \textcolor{comment}{// 3. This notice may not be removed or altered from any source distribution.}
23 \textcolor{comment}{//}
25 \textcolor{comment}{}
26 \textcolor{preprocessor}{#ifndef RESOURCE\_PATH\_HPP}
27 \textcolor{preprocessor}{#define RESOURCE\_PATH\_HPP}
28 
30 \textcolor{comment}{// Headers}
32 \textcolor{comment}{}\textcolor{preprocessor}{#include <string>}
33 
41 std::string resourcePath(\textcolor{keywordtype}{void});
42 
43 \textcolor{preprocessor}{#endif}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramResourcePath_cpp}{}\subsection{Resource\+Path.\+cpp}\label{_benchmark_program_BenchmarkProgramResourcePath_cpp}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/src/\+Resource\+Path.cpp} 
\begin{DoxyCodeInclude}
1 \textcolor{preprocessor}{#include "../include/ResourcePath.hpp"}
2 
4 std::string resourcePath(\textcolor{keywordtype}{void})
5 \{
6     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Resources/"};
7 \}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramResourcePath_mm}{}\subsection{Resource\+Path.\+mm}\label{_benchmark_program_BenchmarkProgramResourcePath_mm}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/src/\+Resource\+Path.mm} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
3 \textcolor{comment}{// SFML - Simple and Fast Multimedia Library}
4 \textcolor{comment}{// Copyright (C) 2007-2013 Marco Antognini (antognini.marco@gmail.com),}
5 \textcolor{comment}{//                         Laurent Gomila (laurent.gom@gmail.com),}
6 \textcolor{comment}{//}
7 \textcolor{comment}{// This software is provided 'as-is', without any express or implied warranty.}
8 \textcolor{comment}{// In no event will the authors be held liable for any damages arising from the use of this software.}
9 \textcolor{comment}{//}
10 \textcolor{comment}{// Permission is granted to anyone to use this software for any purpose,}
11 \textcolor{comment}{// including commercial applications, and to alter it and redistribute it freely,}
12 \textcolor{comment}{// subject to the following restrictions:}
13 \textcolor{comment}{//}
14 \textcolor{comment}{// 1. The origin of this software must not be misrepresented;}
15 \textcolor{comment}{//    you must not claim that you wrote the original software.}
16 \textcolor{comment}{//    If you use this software in a product, an acknowledgment}
17 \textcolor{comment}{//    in the product documentation would be appreciated but is not required.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// 2. Altered source versions must be plainly marked as such,}
20 \textcolor{comment}{//    and must not be misrepresented as being the original software.}
21 \textcolor{comment}{//}
22 \textcolor{comment}{// 3. This notice may not be removed or altered from any source distribution.}
23 \textcolor{comment}{//}
25 \textcolor{comment}{}
27 \textcolor{comment}{// Headers}
29 \textcolor{comment}{}\textcolor{preprocessor}{#include "../include/ResourcePath.hpp"}
30 \textcolor{preprocessor}{#import <Foundation/Foundation.h>}
31 
33 std::string resourcePath(\textcolor{keywordtype}{void})
34 \{
35     NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
36 
37     std::string rpath;
38     NSBundle* bundle = [NSBundle mainBundle];
39 
40     \textcolor{keywordflow}{if} (bundle == nil) \{
41 \textcolor{preprocessor}{#ifdef DEBUG}
42         NSLog(\textcolor{stringliteral}{@"bundle is nil... thus no resources path can be found."});
43 \textcolor{preprocessor}{#endif}
44     \} \textcolor{keywordflow}{else} \{
45         NSString* path = [bundle resourcePath];
46         rpath = [path UTF8String] + std::string("/");
47     \}
48 
49     [pool drain];
50 
51     \textcolor{keywordflow}{return} rpath;
52 \}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramSyncBouncingCircle}{}\section{Sync\+Bouncing\+Circle}\label{_benchmark_program_BenchmarkProgramSyncBouncingCircle}
\hypertarget{_benchmark_program_BenchmarkProgramSyncBouncingCircle_h}{}\subsection{Sync\+Bouncing\+Circle.\+h}\label{_benchmark_program_BenchmarkProgramSyncBouncingCircle_h}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/include/\+Sync\+Bouncing\+Circle.h} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  SyncBouncingCircle.h}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 2/21/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#ifndef profiler\_SyncBouncingCircle\_h}
10 \textcolor{preprocessor}{#define profiler\_SyncBouncingCircle\_h}
11 
12 \textcolor{preprocessor}{#include <dsf/SynchronizedObject.h>}
13 \textcolor{preprocessor}{#include <SFML/Graphics.hpp>}
14 \textcolor{preprocessor}{#include <cmath>}
15 
16 \textcolor{keyword}{class }SyncBouncingCircle : \textcolor{keyword}{public} dsf::SynchronizedObject, \textcolor{keyword}{public} sf::CircleShape
17 \{
18 \textcolor{keyword}{public}:
19     SyncBouncingCircle();
20     sf::Vector2<float> getVelocity();
21     \textcolor{keywordtype}{void} setVelocity(\textcolor{keyword}{const} sf::Vector2<float>& velocity);
22     \textcolor{keywordtype}{float} getMass();
23     \textcolor{keywordtype}{void} move(\textcolor{keywordtype}{int} width, \textcolor{keywordtype}{int} height);
24     \textcolor{keywordtype}{void} collide(SyncBouncingCircle* sbc);
25     \textcolor{keywordtype}{bool} hasCollision(SyncBouncingCircle* sbc);
26 \textcolor{keyword}{protected}:
27     \textcolor{keywordtype}{void} run() \textcolor{keyword}{override};
28 \textcolor{keyword}{private}:
29     sf::Vector2<float> velocity;
30     \textcolor{keywordtype}{float} mass = 1;
31 \};
32 
33 \textcolor{preprocessor}{#endif}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramSyncBouncingCircle_cpp}{}\subsection{Sync\+Bouncing\+Circle.\+cpp}\label{_benchmark_program_BenchmarkProgramSyncBouncingCircle_cpp}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/src/\+Sync\+Bouncing\+Circle.cpp} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  SyncBouncingCircle.cpp}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 2/21/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#include "../include/SyncBouncingCircle.h"}
10 
11 
12 SyncBouncingCircle::SyncBouncingCircle()  : SynchronizedObject(), CircleShape()
13 \{
14 \}
15 
16 \textcolor{keywordtype}{void} SyncBouncingCircle::run()
17 \{
18     \textcolor{keywordflow}{if}(this->receive())
19         this->process();
20 \}
21 
22 sf::Vector2<float> SyncBouncingCircle::getVelocity() \{
23     \textcolor{keywordflow}{return} this->velocity;
24 \}
25 \textcolor{keywordtype}{void} SyncBouncingCircle::setVelocity(\textcolor{keyword}{const} sf::Vector2<float>& velocity) \{
26     this->velocity = velocity;
27 \}
28 \textcolor{keywordtype}{float} SyncBouncingCircle::getMass() \{
29     \textcolor{keywordflow}{return} this->mass;
30 \}
31 \textcolor{keywordtype}{void} SyncBouncingCircle::move(\textcolor{keywordtype}{int} width, \textcolor{keywordtype}{int} height) \{
32     sf::Vector2<float> nextPosition = this->getPosition() + this->velocity;
33     this->setPosition(nextPosition);
34     \textcolor{keywordflow}{if} (getPosition().x <= 0 || getPosition().x >= width - this->getRadius() * 2) \{
35         this->velocity = sf::Vector2<float>(-this->velocity.x, this->velocity.y);
36     \}
37     \textcolor{keywordflow}{if} (getPosition().y <= 0 || getPosition().y >= height - this->getRadius() * 2) \{
38         this->velocity = sf::Vector2<float>(this->velocity.x, -this->velocity.y);
39     \}
40 \}
41 
42 \textcolor{keywordtype}{void} SyncBouncingCircle::collide(SyncBouncingCircle *sbc)
43 \{
44     \textcolor{keywordflow}{if} (this->hasCollision(sbc))
45     \{
46         sf::Vector2<float> v1 = this->getVelocity();
47         sf::Vector2<float> v2 = sbc->getVelocity();
48         sf::Vector2<float> pos1 = this->getPosition();
49         sf::Vector2<float> pos2 = sbc->getPosition();
50         sf::Vector2<float> n = sf::Vector2<float>(pos2.x - pos1.x, pos2.y - pos1.y);
51         sf::Vector2<float> un = n / sqrtf(n.x * n.x + n.y * n.y);
52         sf::Vector2<float> ut = sf::Vector2<float>(-un.y, un.x);
53         \textcolor{keywordtype}{float} v1n = un.x * v1.x + un.y * v1.y;
54         \textcolor{keywordtype}{float} v1t = ut.x * v1.x + ut.y * v1.y;
55         \textcolor{keywordtype}{float} v2n = un.x * v2.x + un.y * v2.y;
56         \textcolor{keywordtype}{float} v2t = ut.x * v2.x + ut.y * v2.y;
57         \textcolor{keywordtype}{float} m1 = this->getMass();
58         \textcolor{keywordtype}{float} m2 = sbc->getMass();
59         \textcolor{keywordtype}{float} v\_1t = v1t;
60         \textcolor{keywordtype}{float} v\_2t = v2t;
61         \textcolor{keywordtype}{float} v\_1n = (v1n * (m1 - m2) + 2 * m2 * v2n) / (m1 + m2);
62         \textcolor{keywordtype}{float} v\_2n = (v2n * (m2 - m1) + 2 * m1 * v1n) / (m1 + m2);
63         sf::Vector2<float> v\_\_1n = v\_1n * un;
64         sf::Vector2<float> v\_\_1t = v\_1t * ut;
65         sf::Vector2<float> v\_\_2n = v\_2n * un;
66         sf::Vector2<float> v\_\_2t = v\_2t * ut;
67         sf::Vector2<float> v\_1 = v\_\_1n + v\_\_1t;
68         sf::Vector2<float> v\_2 = v\_\_2n + v\_\_2t;
69         this->setVelocity(v\_1);
70         sbc->setVelocity(v\_2);
71     \}
72 \}
73 
74 \textcolor{keywordtype}{bool} SyncBouncingCircle::hasCollision(SyncBouncingCircle *sbc)
75 \{
76     \textcolor{keywordtype}{float} distanceSqr = std::pow(this->getPosition().x - sbc->getPosition().x, 2) + std::pow(this->
      getPosition().y - sbc->getPosition().y, 2);
77     \textcolor{keywordflow}{return} distanceSqr <= std::pow(this->getRadius() + sbc->getRadius(), 2);
78 \}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramSyncCircle}{}\section{Sync\+Circle}\label{_benchmark_program_BenchmarkProgramSyncCircle}
\hypertarget{_benchmark_program_BenchmarkProgramSyncCircle_h}{}\subsection{Sync\+Circle.\+h}\label{_benchmark_program_BenchmarkProgramSyncCircle_h}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/include/\+Sync\+Circle.h} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  SyncCircle.h}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 2/21/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#ifndef profiler\_SyncCircle\_h}
10 \textcolor{preprocessor}{#define profiler\_SyncCircle\_h}
11 
12 \textcolor{preprocessor}{#include <dsf/SynchronizedObject.h>}
13 \textcolor{preprocessor}{#include <SFML/Graphics.hpp>}
14 
15 \textcolor{keyword}{class }SyncCircle : \textcolor{keyword}{public} dsf::SynchronizedObject, \textcolor{keyword}{public} sf::CircleShape
16 \{
17 \textcolor{keyword}{public}:
18     SyncCircle();
19 \textcolor{keyword}{protected}:
20     \textcolor{keywordtype}{void} run() \textcolor{keyword}{override};
21 \};
22 
23 \textcolor{preprocessor}{#endif}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramSyncCircle_cpp}{}\subsection{Sync\+Circle.\+cpp}\label{_benchmark_program_BenchmarkProgramSyncCircle_cpp}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/src/\+Sync\+Circle.cpp} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  SyncCircle.cpp}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 2/21/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#include "../include/SyncCircle.h"}
10 
11 SyncCircle::SyncCircle()  : SynchronizedObject(), CircleShape()
12 \{
13 \}
14 
15 \textcolor{keywordtype}{void} SyncCircle::run()
16 \{
17     \textcolor{keywordflow}{if}(this->receive())
18         this->process();
19 \}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramSyncFlockingBoid}{}\section{Sync\+Flocking\+Boid}\label{_benchmark_program_BenchmarkProgramSyncFlockingBoid}
\hypertarget{_benchmark_program_BenchmarkProgramSyncFlockingBoid_h}{}\subsection{Sync\+Flocking\+Boid.\+h}\label{_benchmark_program_BenchmarkProgramSyncFlockingBoid_h}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/include/\+Sync\+Flocking\+Boid.h} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  SyncFlockingBoid.h}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 3/12/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#ifndef profiler\_SyncFlockingBoid\_h}
10 \textcolor{preprocessor}{#define profiler\_SyncFlockingBoid\_h}
11 
12 \textcolor{preprocessor}{#include <dsf/SynchronizedObject.h>}
13 \textcolor{preprocessor}{#include <dsf/SynchronizedVar.h>}
14 \textcolor{preprocessor}{#include <SFML/Graphics.hpp>}
15 \textcolor{preprocessor}{#include <yctools/Random.h>}
16 \textcolor{preprocessor}{#include "SyncVector3D.h"}
17 
18 \textcolor{keyword}{class }SyncFlockingBoid : \textcolor{keyword}{public} dsf::SynchronizedObject, \textcolor{keyword}{public} sf::CircleShape
19 \{
20 \textcolor{keyword}{public}:
21     SyncVector3D* loc;
22     SyncVector3D* vel;
23     SyncVector3D* acc;
24     \textcolor{keywordtype}{float} r;
25     \textcolor{keywordtype}{float} maxforce;    \textcolor{comment}{// Maximum steering force}
26     \textcolor{keywordtype}{float} maxspeed;    \textcolor{comment}{// Maximum speed}
27     SyncFlockingBoid();
28     ~SyncFlockingBoid();
29     SyncFlockingBoid(Vector3D* loc, \textcolor{keywordtype}{float} ms, \textcolor{keywordtype}{float} mf);
30     \textcolor{keywordtype}{void} run(std::vector<SyncFlockingBoid*>* boids, sf::RenderWindow* window);
31     Vector3D steer(Vector3D* target, \textcolor{keywordtype}{bool} slowdown);
32     Vector3D separate (std::vector<SyncFlockingBoid*>* boids);
33     Vector3D align (std::vector<SyncFlockingBoid*>* boids);
34     Vector3D cohesion (std::vector<SyncFlockingBoid*>* boids);
35 \textcolor{keyword}{protected}:
36     \textcolor{keywordtype}{void} run() \textcolor{keyword}{override};
37 \};
38 
39 \textcolor{preprocessor}{#endif}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramSyncFlockingBoid_cpp}{}\subsection{Sync\+Flocking\+Boid.\+cpp}\label{_benchmark_program_BenchmarkProgramSyncFlockingBoid_cpp}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/src/\+Sync\+Flocking\+Boid.cpp} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  SyncFlockingBoid.cpp}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 3/12/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#include "../include/SyncFlockingBoid.h"}
10 
11 SyncFlockingBoid::SyncFlockingBoid() : SynchronizedObject(), CircleShape()
12 \{
13 \}
14 SyncFlockingBoid::~SyncFlockingBoid()
15 \{
16     \textcolor{keyword}{delete} this->acc;
17     \textcolor{keyword}{delete} this->vel;
18     \textcolor{keyword}{delete} this->loc;
19 \}
20 SyncFlockingBoid::SyncFlockingBoid(Vector3D* loc, \textcolor{keywordtype}{float} ms, \textcolor{keywordtype}{float} mf) : SynchronizedObject(), CircleShape()
21 \{
22     this->acc = \textcolor{keyword}{new} SyncVector3D(0,0);
23     this->vel = \textcolor{keyword}{new} SyncVector3D(yc::Random().randFloat(-1,1), yc::Random().randFloat(-1,1));
24     this->loc = \textcolor{keyword}{new} SyncVector3D(loc->getX(), loc->getY(), loc->getZ());
25     \textcolor{keyword}{delete} loc;
26     r = 2.0f;
27     maxspeed = ms;
28     maxforce = mf;
29 \}
30 
31 \textcolor{keywordtype}{void} SyncFlockingBoid::run(std::vector<SyncFlockingBoid*>* boids, sf::RenderWindow* window) \{
32     \textcolor{comment}{//flock(boids);}
33     \textcolor{comment}{//update();}
34     \textcolor{comment}{//borders(window->getSize().x, window->getSize().y);}
35     \textcolor{comment}{//render(window);}
36     
37     \textcolor{comment}{// We accumulate a new acceleration each time based on three rules}
38     Vector3D sep = separate(boids);   \textcolor{comment}{// Separation}
39     Vector3D ali = align(boids);      \textcolor{comment}{// Alignment}
40     Vector3D coh = cohesion(boids);   \textcolor{comment}{// Cohesion}
41     
42     \textcolor{comment}{// Arbitrarily weight these forces}
43     sep *= 2.0f;
44     ali *= 1.0f;
45     coh *= 1.0f;
46     
47     \textcolor{keyword}{auto} acc = Vector3D(*this->acc);
48     \textcolor{keyword}{auto} loc = Vector3D(this->loc->getX(), this->loc->getY());
49     \textcolor{keyword}{auto} vel = Vector3D(*this->vel);
50     
51     \textcolor{comment}{// Add the force vectors to acceleration}
52     acc += sep;
53     acc += ali;
54     acc += coh;
55     
56     \textcolor{comment}{// Method to update location}
57     \textcolor{comment}{// Update velocity}
58     vel += acc;
59     
60     \textcolor{comment}{// Limit speed}
61     vel.limit(maxspeed);
62     
63     loc += vel;
64     
65     \textcolor{comment}{// Reset accelertion to 0 each cycle}
66     acc.setXYZ(0,0,0);
67     
68     \textcolor{comment}{// Wraparound}
69     \textcolor{keyword}{auto} width = window->getSize().x;
70     \textcolor{keyword}{auto} height = window->getSize().y;
71     \textcolor{keywordflow}{if} (loc.getX() < -r)
72         loc.setX(width+r);
73     \textcolor{keywordflow}{if} (loc.getY() < -r)
74         loc.setY(height+r);
75     \textcolor{keywordflow}{if} (loc.getX() > width+r)
76         loc.setX(-r);
77     \textcolor{keywordflow}{if} (loc.getY() > height+r)
78         loc.setY(-r);
79     
80     
81     this->acc->setXYZ(acc);
82     this->loc->setXYZ(loc);
83     this->vel->setXYZ(vel);
84     this->setPosition(this->loc->getX(), this->loc->getY());
85     this->setRadius(r);
86 \}
87 
88 
89 \textcolor{comment}{// A method that calculates a steering vector towards a target}
90 \textcolor{comment}{// Takes a second argument, if true, it slows down as it approaches the target}
91 
92 Vector3D SyncFlockingBoid::steer(Vector3D* target, \textcolor{keywordtype}{bool} slowdown) \{
93     Vector3D steer;  \textcolor{comment}{// The steering vector}
94     Vector3D desired = *target - *this->loc;  \textcolor{comment}{// A vector pointing from the location to the target}
95     \textcolor{keywordtype}{float} d = desired.magnitude(); \textcolor{comment}{// Distance from the target is the magnitude of the vector}
96     
97     \textcolor{comment}{// If the distance is greater than 0, calc steering (otherwise return zero vector)}
98     \textcolor{keywordflow}{if} (d > 0) \{
99         \textcolor{comment}{// Normalize desired}
100         desired.normalize();
101         
102         \textcolor{comment}{// Two options for desired vector magnitude (1 -- based on distance, 2 -- maxspeed)}
103         \textcolor{keywordflow}{if} ((slowdown) && (d < 100.0f))
104             desired *= maxspeed * (d / 100.0f); \textcolor{comment}{// This damping is somewhat arbitrary}
105         \textcolor{keywordflow}{else}
106             desired *= maxspeed;
107         
108         \textcolor{comment}{// Steering = Desired minus Velocity}
109         steer = desired - *this->vel;
110         steer.limit(maxforce);  \textcolor{comment}{// Limit to maximum steering force}
111         
112     \} \textcolor{keywordflow}{else} \{
113         steer = Vector3D(0,0);
114     \}
115     \textcolor{keywordflow}{return} steer;
116 \}
117 
118 \textcolor{comment}{// Separation}
119 \textcolor{comment}{// Method checks for nearby boids and steers away}
120 Vector3D SyncFlockingBoid::separate (std::vector<SyncFlockingBoid*>* boids) \{
121     \textcolor{keywordtype}{float} desiredseparation = 25.0f;
122     Vector3D sum = Vector3D(0,0,0);
123     \textcolor{keywordtype}{int} count = 0;
124     
125     \textcolor{comment}{// For every boid in the system, check if it's too close}
126     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} other: *boids) \{
127         \textcolor{keywordtype}{float} d = this->loc->distance(*other->loc);
128         
129         \textcolor{comment}{// If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)}
130         \textcolor{keywordflow}{if} ((d > 0) && (d < desiredseparation)) \{
131             \textcolor{comment}{// Calculate vector pointing away from neighbor}
132             Vector3D diff = *this->loc - *other->loc;
133             diff.normalize();
134             diff /= d;        \textcolor{comment}{// Weight by distance}
135             sum += diff;
136             count++;            \textcolor{comment}{// Keep track of how many}
137         \}
138     \}
139     
140     \textcolor{comment}{// Average -- divide by how many}
141     \textcolor{keywordflow}{if} (count > 0)
142         sum /= count;
143     \textcolor{keywordflow}{return} sum;
144 \}
145 
146 
147 
148 \textcolor{comment}{// Alignment}
149 \textcolor{comment}{// For every nearby boid in the system, calculate the average velocity}
150 Vector3D SyncFlockingBoid::align (std::vector<SyncFlockingBoid*>* boids) \{
151     \textcolor{keywordtype}{float} neighbordist = 50.0f;
152     Vector3D sum = Vector3D(0,0,0);
153     \textcolor{keywordtype}{int} count = 0;
154     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} & other : *boids) \{
155         \textcolor{keywordtype}{float} d = this->loc->distance(*other->loc);
156         \textcolor{keywordflow}{if} ((d > 0) && (d < neighbordist)) \{
157             sum += *other->vel;
158             count++;
159         \}
160     \}
161     \textcolor{keywordflow}{if} (count > 0) \{
162         sum /= count;
163         sum.limit(maxforce);
164     \}
165     \textcolor{keywordflow}{return} sum;
166 \}
167 
168 \textcolor{comment}{// Cohesion}
169 \textcolor{comment}{// For the average location (i.e. center) of all nearby boids, calculate steering vector towards that
       location}
170 Vector3D SyncFlockingBoid::cohesion (std::vector<SyncFlockingBoid*>* boids) \{
171     \textcolor{keywordtype}{float} neighbordist = 50.0f;
172     Vector3D sum = Vector3D(0,0,0);   \textcolor{comment}{// Start with empty vector to accumulate all locations}
173     \textcolor{keywordtype}{int} count = 0;
174     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} & other: *boids) \{
175         \textcolor{keywordtype}{float} d = this->loc->distance(*other->loc);
176         \textcolor{keywordflow}{if} ((d > 0) && (d < neighbordist)) \{
177             sum += *other->loc; \textcolor{comment}{// Add location}
178             count++;
179         \}
180     \}
181     
182     \textcolor{keywordflow}{if} (count > 0) \{
183         sum /= count;
184         \textcolor{keywordflow}{return} steer(&sum,\textcolor{keyword}{false});  \textcolor{comment}{// Steer towards the location}
185     \}
186     \textcolor{keywordflow}{return} sum;
187 \}
188 
189 \textcolor{keywordtype}{void} SyncFlockingBoid::run()
190 \{
191     \textcolor{keywordflow}{if}(this->receive())
192     \{
193         this->loc->synchronise();
194         this->acc->synchronise();
195         this->vel->synchronise();
196         this->process();
197     \}
198 \}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramSyncVector3D}{}\section{Sync\+Vector3\+D}\label{_benchmark_program_BenchmarkProgramSyncVector3D}
\hypertarget{_benchmark_program_BenchmarkProgramSyncVector3D_h}{}\subsection{Sync\+Vector3\+D.\+h}\label{_benchmark_program_BenchmarkProgramSyncVector3D_h}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/include/\+Sync\+Vector3\+D.h} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  SyncVector3D.h}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 3/22/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#ifndef profiler\_SyncVector3D\_h}
10 \textcolor{preprocessor}{#define profiler\_SyncVector3D\_h}
11 
12 \textcolor{preprocessor}{#include "Vector3D.h"}
13 \textcolor{preprocessor}{#include <dsf/Synchronisable.h>}
14 
15 \textcolor{keyword}{class }SyncVector3D : \textcolor{keyword}{public} dsf::Synchronisable<Vector3D>, \textcolor{keyword}{public} Vector3D \{
16 \textcolor{keyword}{public}:
17     \textcolor{keyword}{explicit} SyncVector3D(\textcolor{keywordtype}{float} x=0, \textcolor{keywordtype}{float} y=0, \textcolor{keywordtype}{float} z=0);
18     \textcolor{keywordtype}{void} setX(\textcolor{keywordtype}{float} x) \textcolor{keyword}{override};
19     \textcolor{keywordtype}{void} setY(\textcolor{keywordtype}{float} y) \textcolor{keyword}{override};
20     \textcolor{keywordtype}{void} setZ(\textcolor{keywordtype}{float} z) \textcolor{keyword}{override};
21     \textcolor{keywordtype}{void} add(\textcolor{keyword}{const} Vector3D& v) \textcolor{keyword}{override};
22     \textcolor{keywordtype}{void} sub(\textcolor{keyword}{const} Vector3D& v) \textcolor{keyword}{override};
23     \textcolor{keywordtype}{void} mul(\textcolor{keywordtype}{float} n) \textcolor{keyword}{override};
24     \textcolor{keywordtype}{void} div(\textcolor{keywordtype}{float} n) \textcolor{keyword}{override};
25     \textcolor{keywordtype}{void} synchronise() \textcolor{keyword}{override};
26 \};
27 
28 \textcolor{preprocessor}{#endif}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramSyncVector3D_cpp}{}\subsection{Sync\+Vector3\+D.\+cpp}\label{_benchmark_program_BenchmarkProgramSyncVector3D_cpp}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/src/\+Sync\+Vector3\+D.cpp} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  Vector3D.cpp}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 3/22/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#include "../include/SyncVector3D.h"}
10 
11 
12 SyncVector3D::SyncVector3D(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y, \textcolor{keywordtype}{float} z) : Vector3D(x, y, z) \{
13     this->next = \textcolor{keyword}{new} Vector3D(x, y, z);
14 \}
15 
16 \textcolor{keywordtype}{void} SyncVector3D::setX(\textcolor{keywordtype}{float} x) \{
17     this->next->setX(x);
18 \}
19 
20 \textcolor{keywordtype}{void} SyncVector3D::setY(\textcolor{keywordtype}{float} y) \{
21     this->next->setY(y);
22 \}
23 
24 \textcolor{keywordtype}{void} SyncVector3D::setZ(\textcolor{keywordtype}{float} z) \{
25     this->next->setZ(z);
26 \}
27 
28 \textcolor{keywordtype}{void} SyncVector3D::add(\textcolor{keyword}{const} Vector3D& v) \{
29     this->next->add(v);
30 \}
31 
32 \textcolor{keywordtype}{void} SyncVector3D::sub(\textcolor{keyword}{const} Vector3D& v) \{
33     this->next->sub(v);
34 \}
35 
36 \textcolor{keywordtype}{void} SyncVector3D::mul(\textcolor{keywordtype}{float} n) \{
37     this->next->mul(n);
38 \}
39 
40 \textcolor{keywordtype}{void} SyncVector3D::div(\textcolor{keywordtype}{float} n) \{
41     this->next->div(n);
42 \}
43 
44 \textcolor{keywordtype}{void} SyncVector3D::synchronise() \{
45     this->x = this->next->getX();
46     this->y = this->next->getY();
47     this->z = this->next->getZ();
48 \}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramVector3D}{}\section{Vector3\+D}\label{_benchmark_program_BenchmarkProgramVector3D}
\hypertarget{_benchmark_program_BenchmarkProgramVector3D_h}{}\subsection{Vector3\+D.\+h}\label{_benchmark_program_BenchmarkProgramVector3D_h}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/include/\+Vector3\+D.h} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  Vector3D.h}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 3/22/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#ifndef profiler\_Vector3D\_h}
10 \textcolor{preprocessor}{#define profiler\_Vector3D\_h}
11 
12 \textcolor{preprocessor}{#include <cmath>}
13 
14 \textcolor{keyword}{class }Vector3D \{
15 \textcolor{keyword}{protected}:
16     \textcolor{keywordtype}{float} x;
17     \textcolor{keywordtype}{float} y;
18     \textcolor{keywordtype}{float} z;
19 \textcolor{keyword}{public}:
20     \textcolor{keyword}{explicit} Vector3D(\textcolor{keywordtype}{float} x=0, \textcolor{keywordtype}{float} y=0, \textcolor{keywordtype}{float} z=0);
21     \textcolor{keyword}{virtual} ~Vector3D();
22     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} Vector3D& obj);
23     
24     \textcolor{keywordtype}{float} getX();
25     \textcolor{keywordtype}{float} getY();
26     \textcolor{keywordtype}{float} getZ();
27     
28     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setX(\textcolor{keywordtype}{float} x);
29     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setY(\textcolor{keywordtype}{float} y);
30     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setZ(\textcolor{keywordtype}{float} z);
31     
32     \textcolor{keywordtype}{void} setXY(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y);
33     \textcolor{keywordtype}{void} setXYZ(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y, \textcolor{keywordtype}{float} z);
34     \textcolor{keywordtype}{void} setXYZ(\textcolor{keyword}{const} Vector3D& v);
35     
36     \textcolor{keywordtype}{float} magnitude();
37     \textcolor{keywordtype}{void} normalize();
38     \textcolor{keywordtype}{void} limit(\textcolor{keywordtype}{float} max);
39     \textcolor{keyword}{virtual} \textcolor{keywordtype}{float} heading2D();
40     \textcolor{keywordtype}{float} distance (\textcolor{keyword}{const} Vector3D& v);
41     
42     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} add(\textcolor{keyword}{const} Vector3D& v);
43     \textcolor{keywordtype}{void} operator+=(\textcolor{keyword}{const} Vector3D& v);
44     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sub(\textcolor{keyword}{const} Vector3D& v);
45     \textcolor{keywordtype}{void} operator-=(\textcolor{keyword}{const} Vector3D& v);
46     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} mul(\textcolor{keywordtype}{float} n);
47     \textcolor{keywordtype}{void} operator*=(\textcolor{keywordtype}{float} n);
48     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} div(\textcolor{keywordtype}{float} n);
49     \textcolor{keywordtype}{void} operator/=(\textcolor{keywordtype}{float} n);
50     
51     
52     Vector3D operator+(\textcolor{keyword}{const} Vector3D& v) \textcolor{keyword}{const};
53     Vector3D operator-(\textcolor{keyword}{const} Vector3D& v) \textcolor{keyword}{const};
54     Vector3D operator/(\textcolor{keywordtype}{float} n) \textcolor{keyword}{const};
55     Vector3D operator*(\textcolor{keywordtype}{float} n) \textcolor{keyword}{const};
56     
57 \};
58 
59 \textcolor{preprocessor}{#endif}
\end{DoxyCodeInclude}
 \hypertarget{_benchmark_program_BenchmarkProgramVector3D_cpp}{}\subsection{Vector3\+D.\+cpp}\label{_benchmark_program_BenchmarkProgramVector3D_cpp}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/src/\+Vector3\+D.cpp} 
\begin{DoxyCodeInclude}
1 \textcolor{comment}{//}
2 \textcolor{comment}{//  Vector3D.cpp}
3 \textcolor{comment}{//  profiler}
4 \textcolor{comment}{//}
5 \textcolor{comment}{//  Created by Yu Chen on 3/22/15.}
6 \textcolor{comment}{//}
7 \textcolor{comment}{//}
8 
9 \textcolor{preprocessor}{#include "../include/Vector3D.h"}
10 
11 
12 Vector3D::Vector3D(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y, \textcolor{keywordtype}{float} z) : x(x), y(y), z(z) \{
13 \}
14 
15 Vector3D::~Vector3D()\{
16 \}
17 
18 \textcolor{keywordtype}{void} Vector3D::operator=(\textcolor{keyword}{const} Vector3D& obj)
19 \{
20     this->setXYZ(obj.x, obj.y, obj.z);
21 \}
22 
23 \textcolor{keywordtype}{float} Vector3D::getX() \{
24     \textcolor{keywordflow}{return} this->x;
25 \}
26 \textcolor{keywordtype}{float} Vector3D::getY() \{
27     \textcolor{keywordflow}{return} this->y;
28 \}
29 \textcolor{keywordtype}{float} Vector3D::getZ() \{
30     \textcolor{keywordflow}{return} this->z;
31 \}
32 
33 \textcolor{keywordtype}{void} Vector3D::setX(\textcolor{keywordtype}{float} x) \{
34     this->x = x;
35 \}
36 
37 \textcolor{keywordtype}{void} Vector3D::setY(\textcolor{keywordtype}{float} y) \{
38     this->y = y;
39 \}
40 
41 \textcolor{keywordtype}{void} Vector3D::setZ(\textcolor{keywordtype}{float} z) \{
42     this->z = z;
43 \}
44 
45 \textcolor{keywordtype}{void} Vector3D::setXY(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y) \{
46     this->setX(x);
47     this->setY(y);
48 \}
49 
50 \textcolor{keywordtype}{void} Vector3D::setXYZ(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y, \textcolor{keywordtype}{float} z) \{
51     this->setXY(x, y);
52     this->setZ(z);
53 \}
54 
55 \textcolor{keywordtype}{void} Vector3D::setXYZ(\textcolor{keyword}{const} Vector3D& v) \{
56     this->setXYZ(v.x, v.y, v.z);
57 \}
58 
59 \textcolor{keywordtype}{float} Vector3D::magnitude() \{
60     \textcolor{keywordflow}{return} std::sqrt(std::pow(this->getX(), 2)
61                       + std::pow(this->getY(), 2)
62                       + std::pow(this->getZ(), 2));
63 \}
64 
65 \textcolor{keywordtype}{void} Vector3D::normalize() \{
66     \textcolor{keywordtype}{float} m = magnitude();
67     \textcolor{keywordflow}{if} (m > 0)
68         div(m);
69 \}
70 
71 \textcolor{keywordtype}{void} Vector3D::limit(\textcolor{keywordtype}{float} max) \{
72     \textcolor{keywordflow}{if} (magnitude() > max) \{
73         normalize();
74         mul(max);
75     \}
76 \}
77 
78 \textcolor{keywordtype}{float} Vector3D::distance (\textcolor{keyword}{const} Vector3D& v) \{
79     \textcolor{keywordtype}{float} dx = x - v.x;
80     \textcolor{keywordtype}{float} dy = y - v.y;
81     \textcolor{keywordtype}{float} dz = z - v.z;
82     \textcolor{keywordflow}{return} std::sqrt(dx*dx + dy*dy + dz*dz);
83 \}
84 
85 \textcolor{keywordtype}{float} Vector3D::heading2D() \{
86     \textcolor{keywordflow}{return} -std::atan2(-this->getY(), this->getX());
87 \}
88 
89 \textcolor{keywordtype}{void} Vector3D::add(\textcolor{keyword}{const} Vector3D& v) \{
90     x += v.x;
91     y += v.y;
92     z += v.z;
93 \}
94 
95 \textcolor{keywordtype}{void} Vector3D::operator+=(\textcolor{keyword}{const} Vector3D& v) \{
96     add(v);
97 \}
98 
99 \textcolor{keywordtype}{void} Vector3D::sub(\textcolor{keyword}{const} Vector3D& v) \{
100     x -= v.x;
101     y -= v.y;
102     z -= v.z;
103 \}
104 
105 \textcolor{keywordtype}{void} Vector3D::operator-=(\textcolor{keyword}{const} Vector3D& v) \{
106     sub(v);
107 \}
108 
109 \textcolor{keywordtype}{void} Vector3D::mul(\textcolor{keywordtype}{float} n) \{
110     x *= n;
111     y *= n;
112     z *= n;
113 \}
114 
115 \textcolor{keywordtype}{void} Vector3D::operator*=(\textcolor{keywordtype}{float} n) \{
116     mul(n);
117 \}
118 
119 \textcolor{keywordtype}{void} Vector3D::div(\textcolor{keywordtype}{float} n) \{
120     x /= n;
121     y /= n;
122     z /= n;
123 \}
124 
125 \textcolor{keywordtype}{void} Vector3D::operator/=(\textcolor{keywordtype}{float} n) \{
126     div(n);
127 \}
128 
129 Vector3D Vector3D::operator+(\textcolor{keyword}{const} Vector3D& v)\textcolor{keyword}{ const }\{
130     \textcolor{keywordflow}{return} Vector3D(x + v.x, y + v.y, z + v.z);
131 \}
132 
133 Vector3D Vector3D::operator-(\textcolor{keyword}{const} Vector3D& v)\textcolor{keyword}{ const }\{
134     \textcolor{keywordflow}{return} Vector3D(x - v.x, y - v.y, z - v.z);
135 \}
136 
137 Vector3D Vector3D::operator/(\textcolor{keywordtype}{float} n)\textcolor{keyword}{ const }\{
138     \textcolor{keywordflow}{return} Vector3D(x/n, y/n, z/n);
139 \}
140 
141 Vector3D Vector3D::operator*(\textcolor{keywordtype}{float} n)\textcolor{keyword}{ const }\{
142     \textcolor{keywordflow}{return} Vector3D(x*n, y*n, z*n);
143 \}
\end{DoxyCodeInclude}
\hypertarget{_benchmark_program_BenchmarkProgramMain}{}\section{main}\label{_benchmark_program_BenchmarkProgramMain}
\hypertarget{_benchmark_program_BenchmarkProgramMainCPP}{}\subsection{main.\+cpp}\label{_benchmark_program_BenchmarkProgramMainCPP}
{\bfseries Path\+:} {\itshape \$\+P\+R\+O\+J\+E\+C\+T\+\_\+\+D\+I\+R/profiler/src/main.cpp} 
\begin{DoxyCodeInclude}
1 \textcolor{preprocessor}{#include <SFML/Graphics.hpp>}
2 \textcolor{preprocessor}{#include <dsf/DualStateFramework.h>}
3 \textcolor{preprocessor}{#include "../include/ResourcePath.hpp"}
4 \textcolor{preprocessor}{#include "../include/FPS.h"}
5 \textcolor{preprocessor}{#include "../include/MyDSF.h"}
6 \textcolor{preprocessor}{#include "../include/SyncCircle.h"}
7 \textcolor{preprocessor}{#include "../include/RandomCircleManager.h"}
8 \textcolor{preprocessor}{#include "../include/SyncBouncingCircle.h"}
9 \textcolor{preprocessor}{#include "../include/BouncingCircleManager.h"}
10 \textcolor{preprocessor}{#include "../include/SyncFlockingBoid.h"}
11 \textcolor{preprocessor}{#include "../include/FlockingBoidManager.h"}
12 
13 \textcolor{keywordtype}{void} profile(\textcolor{keywordtype}{int} maxNumberOfThreads, \textcolor{keywordtype}{int} numberOfObjects, \textcolor{keywordtype}{int} durationPerIterator, \textcolor{keywordtype}{int} method);
14 \textcolor{keywordtype}{void} configure();
15 
16 \textcolor{comment}{// Constances}
17 \textcolor{keyword}{const} sf::Vector2f WINDOW\_SIZE(800, 600);
18 \textcolor{keyword}{const} \textcolor{keywordtype}{int} CHAR\_SIZE = 20;
19 \textcolor{keyword}{const} sf::Vector2f LEFT\_CORNER(100, 100);
20 \textcolor{keyword}{const} sf::Vector2f RIGHT\_CORNER(700, 100);
21 \textcolor{keyword}{const} sf::Vector2f INTENT(500, 25);
22 \textcolor{keyword}{const} sf::Vector2f SHADOW\_SIZE(WINDOW\_SIZE.x - LEFT\_CORNER.x * 2, INTENT.y);
23 \textcolor{keyword}{const} \textcolor{keywordtype}{int} MAX\_NUMBER\_OF\_THREADS = 64;
24 \textcolor{keyword}{const} \textcolor{keywordtype}{int} MIN\_NUMBER\_OF\_THREADS = 2;
25 \textcolor{keyword}{const} \textcolor{keywordtype}{int} MAX\_NUMBER\_OF\_OBJECTS = 2000;
26 \textcolor{keyword}{const} \textcolor{keywordtype}{int} MIN\_NUMBER\_OF\_OBJECTS = 100;
27 \textcolor{keyword}{const} \textcolor{keywordtype}{int} MAX\_DURATION = 360;
28 \textcolor{keyword}{const} \textcolor{keywordtype}{int} MIN\_DURATION = 5;
29 \textcolor{keyword}{const} \textcolor{keywordtype}{int} NUMBER\_OF\_PROFILING\_METHODS = 3;
30 \textcolor{keyword}{const} std::string profilingMethods[NUMBER\_OF\_PROFILING\_METHODS] = \{
31     \textcolor{stringliteral}{"Random"}, \textcolor{stringliteral}{"Collision"}, \textcolor{stringliteral}{"Flocking"}
32 \};
33 \textcolor{keyword}{const} \textcolor{keywordtype}{int} NUMBER\_OF\_SELECTIONS = 4;
34 \textcolor{comment}{// Default Configurations}
35 \textcolor{keywordtype}{int} currentSelection = 1;
36 \textcolor{keywordtype}{int} maxNumberOfThreads = 4;
37 \textcolor{keywordtype}{int} numberOfObjects = 1000;
38 \textcolor{keywordtype}{int} durationPerIterator = 60;
39 \textcolor{keywordtype}{int} profilingMethodIndex = 0;
40 
41 \textcolor{keywordtype}{int} main()
42 \{
43     configure();
44     \textcolor{keywordflow}{return} 0;
45 \}
46 
47 \textcolor{keywordtype}{void} configure()
48 \{
49     \textcolor{keywordtype}{bool} ready = \textcolor{keyword}{false};
50     \textcolor{comment}{// Create the main window}
51     sf::RenderWindow window(sf::VideoMode(WINDOW\_SIZE.x, WINDOW\_SIZE.y), \textcolor{stringliteral}{"DSF Profiler"});
52     sf::Font font;
53     sf::Text maxNumberOfThreadsText;
54     sf::Text numberOfObjectsText;
55     sf::Text durationPerIteratorText;
56     sf::Text profilingMethodText;
57     sf::Text maxNumberOfThreadsValue;
58     sf::Text numberOfObjectsValue;
59     sf::Text durationPerIteratorValue;
60     sf::Text profilingMethodValue;
61     sf::Text help;
62     font.loadFromFile(resourcePath() + \textcolor{stringliteral}{"sansation.ttf"});
63     maxNumberOfThreadsText.setFont(font);
64     numberOfObjectsText.setFont(font);
65     durationPerIteratorText.setFont(font);
66     profilingMethodText.setFont(font);
67     maxNumberOfThreadsValue.setFont(font);
68     numberOfObjectsValue.setFont(font);
69     durationPerIteratorValue.setFont(font);
70     profilingMethodValue.setFont(font);
71     help.setFont(font);
72     maxNumberOfThreadsText.setCharacterSize(CHAR\_SIZE);
73     numberOfObjectsText.setCharacterSize(CHAR\_SIZE);
74     durationPerIteratorText.setCharacterSize(CHAR\_SIZE);
75     profilingMethodText.setCharacterSize(CHAR\_SIZE);
76     maxNumberOfThreadsValue.setCharacterSize(CHAR\_SIZE);
77     numberOfObjectsValue.setCharacterSize(CHAR\_SIZE);
78     durationPerIteratorValue.setCharacterSize(CHAR\_SIZE);
79     profilingMethodValue.setCharacterSize(CHAR\_SIZE);
80     help.setCharacterSize(CHAR\_SIZE);
81     maxNumberOfThreadsText.setPosition(LEFT\_CORNER);
82     numberOfObjectsText.setPosition(LEFT\_CORNER.x, LEFT\_CORNER.y + INTENT.y);
83     durationPerIteratorText.setPosition(LEFT\_CORNER.x, LEFT\_CORNER.y + INTENT.y * 2);
84     profilingMethodText.setPosition(LEFT\_CORNER.x, LEFT\_CORNER.y + INTENT.y * 3);
85     maxNumberOfThreadsValue.setPosition(LEFT\_CORNER.x + INTENT.x, LEFT\_CORNER.y);
86     numberOfObjectsValue.setPosition(LEFT\_CORNER.x + INTENT.x, LEFT\_CORNER.y + INTENT.y);
87     durationPerIteratorValue.setPosition(LEFT\_CORNER.x + INTENT.x, LEFT\_CORNER.y + INTENT.y * 2);
88     profilingMethodValue.setPosition(LEFT\_CORNER.x + INTENT.x, LEFT\_CORNER.y + INTENT.y * 3);
89     help.setPosition(LEFT\_CORNER.x, LEFT\_CORNER.y + INTENT.y * 5);
90     maxNumberOfThreadsText.setString(\textcolor{stringliteral}{"Max Number of Threads"});
91     numberOfObjectsText.setString(\textcolor{stringliteral}{"Number of Objects"});
92     durationPerIteratorText.setString(\textcolor{stringliteral}{"Duration per Iterator"});
93     profilingMethodText.setString(\textcolor{stringliteral}{"Profiling Method"});
94     help.setString(\textcolor{stringliteral}{"Press KeyUp, KeyDown, KeyLeft, and KeyRight to edit settings. \(\backslash\)nPress Enter to run the
       application."});
95     
96     sf::RectangleShape shadow;
97     shadow.setFillColor(sf::Color::Blue);
98     shadow.setSize(SHADOW\_SIZE);
99     shadow.setPosition(LEFT\_CORNER.x, LEFT\_CORNER.y + INTENT.y * (currentSelection - 1));
100     \textcolor{keywordflow}{while} (window.isOpen())
101     \{
102         \textcolor{comment}{// Process events}
103         sf::Event event;
104         \textcolor{keywordflow}{while} (window.pollEvent(event))
105         \{
106             \textcolor{comment}{// Close window: exit}
107             \textcolor{keywordflow}{if} (event.type == sf::Event::Closed)
108                 window.close();
109             \textcolor{comment}{// Keyboard Events}
110             \textcolor{keywordflow}{if} (sf::Keyboard::isKeyPressed(sf::Keyboard::Return)) \{
111                 ready = \textcolor{keyword}{true};
112                 window.close();
113             \}
114             \textcolor{keywordflow}{if} (sf::Keyboard::isKeyPressed(sf::Keyboard::Up))
115             \{
116                 \textcolor{keywordflow}{if}(currentSelection > 1)
117                 \{
118                     currentSelection --;
119                     \textcolor{keyword}{auto} spos = shadow.getPosition();
120                     shadow.setPosition(spos.x, spos.y - INTENT.y);
121                 \}
122             \}
123             \textcolor{keywordflow}{if} (sf::Keyboard::isKeyPressed(sf::Keyboard::Down))
124             \{
125                 \textcolor{keywordflow}{if}(currentSelection < NUMBER\_OF\_SELECTIONS)
126                 \{
127                     currentSelection ++;
128                     \textcolor{keyword}{auto} spos = shadow.getPosition();
129                     shadow.setPosition(spos.x, spos.y + INTENT.y);
130                 \}
131             \}
132             \textcolor{keywordflow}{if} (sf::Keyboard::isKeyPressed(sf::Keyboard::Left))
133             \{
134                 \textcolor{keywordflow}{switch} (currentSelection) \{
135                     \textcolor{keywordflow}{case} 1:
136                         \textcolor{keywordflow}{if}(maxNumberOfThreads == MIN\_NUMBER\_OF\_THREADS)
137                             maxNumberOfThreads = MAX\_NUMBER\_OF\_THREADS;
138                         \textcolor{keywordflow}{else}
139                             maxNumberOfThreads --;
140                         \textcolor{keywordflow}{break};
141                     \textcolor{keywordflow}{case} 2:
142                         \textcolor{keywordflow}{if}(numberOfObjects == MIN\_NUMBER\_OF\_OBJECTS)
143                             numberOfObjects = MAX\_NUMBER\_OF\_OBJECTS;
144                         \textcolor{keywordflow}{else}
145                             numberOfObjects -= MIN\_NUMBER\_OF\_OBJECTS;
146                         \textcolor{keywordflow}{break};
147                     \textcolor{keywordflow}{case} 3:
148                         \textcolor{keywordflow}{if}(durationPerIterator == MIN\_DURATION)
149                             durationPerIterator = MAX\_DURATION;
150                         \textcolor{keywordflow}{else}
151                             durationPerIterator -= MIN\_DURATION;
152                         \textcolor{keywordflow}{break};
153                     \textcolor{keywordflow}{case} 4:
154                         \textcolor{keywordflow}{if}(profilingMethodIndex == 0)
155                             profilingMethodIndex = NUMBER\_OF\_PROFILING\_METHODS - 1;
156                         \textcolor{keywordflow}{else}
157                             profilingMethodIndex --;
158                         \textcolor{keywordflow}{break};
159                 \}
160             \}
161             \textcolor{keywordflow}{if} (sf::Keyboard::isKeyPressed(sf::Keyboard::Right))
162             \{
163                 \textcolor{keywordflow}{switch} (currentSelection) \{
164                     \textcolor{keywordflow}{case} 1:
165                         \textcolor{keywordflow}{if}(maxNumberOfThreads == MAX\_NUMBER\_OF\_THREADS)
166                             maxNumberOfThreads = MIN\_NUMBER\_OF\_THREADS;
167                         \textcolor{keywordflow}{else}
168                             maxNumberOfThreads ++;
169                         \textcolor{keywordflow}{break};
170                     \textcolor{keywordflow}{case} 2:
171                         \textcolor{keywordflow}{if}(numberOfObjects == MAX\_NUMBER\_OF\_OBJECTS)
172                             numberOfObjects = MIN\_NUMBER\_OF\_OBJECTS;
173                         \textcolor{keywordflow}{else}
174                             numberOfObjects += MIN\_NUMBER\_OF\_OBJECTS;
175                         \textcolor{keywordflow}{break};
176                     \textcolor{keywordflow}{case} 3:
177                         \textcolor{keywordflow}{if}(durationPerIterator == MAX\_DURATION)
178                             durationPerIterator = MIN\_DURATION;
179                         \textcolor{keywordflow}{else}
180                             durationPerIterator += MIN\_DURATION;
181                         \textcolor{keywordflow}{break};
182                     \textcolor{keywordflow}{case} 4:
183                         \textcolor{keywordflow}{if}(profilingMethodIndex == NUMBER\_OF\_PROFILING\_METHODS - 1)
184                             profilingMethodIndex = 0;
185                         \textcolor{keywordflow}{else}
186                             profilingMethodIndex ++;
187                         \textcolor{keywordflow}{break};
188                 \}
189             \}
190         \}
191         
192         maxNumberOfThreadsValue.setString(std::to\_string(maxNumberOfThreads));
193         numberOfObjectsValue.setString(std::to\_string(numberOfObjects));
194         durationPerIteratorValue.setString(std::to\_string(durationPerIterator));
195         profilingMethodValue.setString(profilingMethods[profilingMethodIndex]);
196         \textcolor{comment}{// Clear screen}
197         window.clear();
198         \textcolor{comment}{// Draw Items}
199         window.draw(shadow);
200         window.draw(maxNumberOfThreadsText);
201         window.draw(numberOfObjectsText);
202         window.draw(durationPerIteratorText);
203         window.draw(profilingMethodText);
204         window.draw(maxNumberOfThreadsValue);
205         window.draw(numberOfObjectsValue);
206         window.draw(durationPerIteratorValue);
207         window.draw(profilingMethodValue);
208         window.draw(help);
209         \textcolor{comment}{// Update the window}
210         window.display();
211     \}
212     \textcolor{keywordflow}{if} (ready)
213         profile(maxNumberOfThreads, numberOfObjects, durationPerIterator, profilingMethodIndex + 1);
214 \}
215 
216 \textcolor{keywordtype}{void} profile(\textcolor{keywordtype}{int} maxNumberOfThreads, \textcolor{keywordtype}{int} numberOfObjects, \textcolor{keywordtype}{int} durationPerIterator, \textcolor{keywordtype}{int} method)
217 \{
218     \textcolor{keywordflow}{if}(method == 1)
219     \{
220         \textcolor{keyword}{auto} dsf = \textcolor{keyword}{new} MyDSF();
221         \textcolor{keyword}{auto} rcm = \textcolor{keyword}{new} RandomCircleManager(dsf);
222         std::vector<SyncCircle*> circles(numberOfObjects);
223         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} & circle : circles)
224         \{
225             circle = \textcolor{keyword}{new} SyncCircle();
226             circle->setRadius(2);
227             circle->setFillColor(sf::Color::Cyan);
228             dsf->add(circle);
229             dsf->send(circle, dsf->sender, rcm->create, \textcolor{keyword}{new} dsf::TaskArgument(circle));
230         \}
231         dsf->duration = durationPerIterator;
232         dsf->maxNumberOfCores = maxNumberOfThreads;
233         dsf->start();
234         \textcolor{keyword}{delete} dsf;
235         \textcolor{keyword}{delete} rcm;
236     \}
237     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(method == 2)
238     \{
239         \textcolor{keyword}{auto} dsf = \textcolor{keyword}{new} MyDSF();
240         \textcolor{keyword}{auto} bcm = \textcolor{keyword}{new} BouncingCircleManager(dsf);
241         \textcolor{keyword}{auto} bouncingCircles = bcm->createRandomCircles(numberOfObjects, 2, 800, 600);
242         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} & bouncingCircle : *bouncingCircles)
243         \{
244             bouncingCircle->setFillColor(sf::Color::Cyan);
245             dsf->add(bouncingCircle);
246             dsf->send(bouncingCircle,
247                       dsf->sender,
248                       bcm->create,
249                       \textcolor{keyword}{new} dsf::TaskArgument(std::make\_tuple(bouncingCircle, bouncingCircles)));
250         \}
251         dsf->duration = durationPerIterator;
252         dsf->maxNumberOfCores = maxNumberOfThreads;
253         dsf->start();
254         \textcolor{keyword}{delete} dsf;
255         \textcolor{keyword}{delete} bcm;
256     \}
257     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(method == 3)
258     \{
259         \textcolor{keyword}{auto} dsf = \textcolor{keyword}{new} MyDSF();
260         \textcolor{keyword}{auto} flockingBoids = \textcolor{keyword}{new} std::vector<SyncFlockingBoid*>();
261         \textcolor{keyword}{auto} fbm = \textcolor{keyword}{new} FlockingBoidManager(dsf);
262         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < numberOfObjects; i++)
263             flockingBoids->push\_back(\textcolor{keyword}{new} SyncFlockingBoid(\textcolor{keyword}{new} Vector3D(dsf->window->getSize().x/2,dsf->
      window->getSize().y/2),2.0f,0.05f));
264         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} & flockingBoid : *flockingBoids)
265         \{
266             flockingBoid->setFillColor(sf::Color::Cyan);
267             dsf->add(flockingBoid);
268             dsf->send(flockingBoid,
269                       dsf->sender,
270                       fbm->create,
271                       \textcolor{keyword}{new} dsf::TaskArgument(std::make\_tuple(flockingBoid, flockingBoids)));
272         \}
273         dsf->duration = durationPerIterator;
274         dsf->maxNumberOfCores = maxNumberOfThreads;
275         dsf->start();
276         \textcolor{keyword}{delete} dsf;
277         \textcolor{keyword}{delete} fbm;
278     \}
279     configure();
280 \}
\end{DoxyCodeInclude}
 